# Практика: Отслеживание владения в простых программах

В этой практической теме мы применим знания о системе владения, перемещении, клонировании, стеке, куче и времени жизни переменных на конкретных примерах. Мы будем анализировать код, отслеживать владение переменными и исправлять ошибки, связанные с системой владения.

## Пример 1: Анализ владения в простой программе

Рассмотрим следующий код и проанализируем, что происходит с владением переменных:

```rust
fn main() {
    // Шаг 1
    let s1 = String::from("привет");
    
    // Шаг 2
    let s2 = s1;
    
    // Шаг 3
    // println!("{}", s1); // Ошибка: значение перемещено
    
    // Шаг 4
    let s3 = String::from("мир");
    
    // Шаг 5
    let s4 = s3.clone();
    
    // Шаг 6
    println!("s2 = {}, s3 = {}, s4 = {}", s2, s3, s4);
}
```

### Анализ:

1. **Шаг 1**: Создается строка `s1` в куче, и переменная `s1` становится ее владельцем.
2. **Шаг 2**: Владение строкой перемещается от `s1` к `s2`. Теперь `s1` недействителен.
3. **Шаг 3**: Попытка использовать `s1` приведет к ошибке компиляции, потому что значение было перемещено.
4. **Шаг 4**: Создается новая строка `s3` в куче, и переменная `s3` становится ее владельцем.
5. **Шаг 5**: Создается полная копия строки `s3`, и переменная `s4` становится владельцем этой копии. Переменная `s3` остается действительной.
6. **Шаг 6**: Выводятся значения `s2`, `s3` и `s4`. Все эти переменные действительны.

## Упражнение 1: Исправление ошибок владения

Исправьте следующий код, чтобы он компилировался и работал правильно:

```rust
fn main() {
    let s = String::from("привет");
    
    takes_ownership(s);
    
    println!("Строка: {}", s); // Ошибка: значение перемещено
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
}
```

### Решение:

Есть несколько способов исправить этот код:

#### Вариант 1: Возврат владения

```rust
fn main() {
    let s = String::from("привет");
    
    let s = takes_ownership(s); // Получаем владение обратно
    
    println!("Строка: {}", s); // Теперь s действителен
}

fn takes_ownership(some_string: String) -> String {
    println!("{}", some_string);
    some_string // Возвращаем владение
}
```

#### Вариант 2: Использование клонирования

```rust
fn main() {
    let s = String::from("привет");
    
    takes_ownership(s.clone()); // Передаем клон, сохраняя оригинал
    
    println!("Строка: {}", s); // s остается действительным
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
}
```

#### Вариант 3: Использование ссылок (заимствование)

```rust
fn main() {
    let s = String::from("привет");
    
    borrows_string(&s); // Передаем ссылку, а не владение
    
    println!("Строка: {}", s); // s остается действительным
}

fn borrows_string(some_string: &String) {
    println!("{}", some_string);
}
```

## Пример 2: Отслеживание владения в функциях

Рассмотрим более сложный пример с несколькими функциями:

```rust
fn main() {
    // Шаг 1
    let s1 = String::from("привет");
    
    // Шаг 2
    let (s2, len) = calculate_length(s1);
    
    // Шаг 3
    println!("Длина строки '{}' равна {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    // Шаг 4
    let length = s.len();
    
    // Шаг 5
    (s, length)
}
```

### Анализ:

1. **Шаг 1**: Создается строка `s1` в куче, и переменная `s1` становится ее владельцем.
2. **Шаг 2**: Вызывается функция `calculate_length`, и владение строкой перемещается от `s1` к параметру `s` функции. Функция возвращает кортеж, и владение строкой перемещается от `s` к `s2`.
3. **Шаг 3**: Выводятся значения `s2` и `len`. Переменная `s2` действительна, потому что она получила владение строкой.
4. **Шаг 4**: Внутри функции `calculate_length` вычисляется длина строки `s`.
5. **Шаг 5**: Функция возвращает кортеж, содержащий строку `s` и ее длину. Владение строкой перемещается обратно в вызывающую функцию.

## Упражнение 2: Реализация функции с возвратом владения

Напишите функцию `append_greeting`, которая принимает строку, добавляет к ней приветствие и возвращает результат. Затем используйте эту функцию в `main`.

### Решение:

```rust
fn main() {
    let name = String::from("Алиса");
    
    let greeting = append_greeting(name);
    
    println!("{}", greeting); // "Привет, Алиса!"
}

fn append_greeting(name: String) -> String {
    let greeting = String::from("Привет, ");
    greeting + &name + "!"
}
```

## Пример 3: Отслеживание владения в структурах

Рассмотрим пример со структурой, которая владеет строкой:

```rust
struct Person {
    name: String,
    age: u32,
}

fn main() {
    // Шаг 1
    let person1 = Person {
        name: String::from("Алиса"),
        age: 30,
    };
    
    // Шаг 2
    let person2 = person1;
    
    // Шаг 3
    // println!("Имя: {}", person1.name); // Ошибка: значение перемещено
    
    // Шаг 4
    println!("Имя: {}, Возраст: {}", person2.name, person2.age);
}
```

### Анализ:

1. **Шаг 1**: Создается структура `person1`, которая владеет строкой `name` и целым числом `age`.
2. **Шаг 2**: Владение структурой перемещается от `person1` к `person2`. Теперь `person1` недействителен.
3. **Шаг 3**: Попытка использовать `person1` приведет к ошибке компиляции, потому что значение было перемещено.
4. **Шаг 4**: Выводятся поля структуры `person2`. Переменная `person2` действительна.

## Упражнение 3: Клонирование структуры

Измените предыдущий пример так, чтобы `person1` оставался действительным после создания `person2`.

### Решение:

```rust
#[derive(Clone)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let person1 = Person {
        name: String::from("Алиса"),
        age: 30,
    };
    
    let person2 = person1.clone();
    
    println!("Имя person1: {}", person1.name); // Теперь это работает
    println!("Имя person2: {}", person2.name);
}
```

## Пример 4: Отслеживание владения в векторах

Рассмотрим пример с вектором строк:

```rust
fn main() {
    // Шаг 1
    let mut v = Vec::new();
    
    // Шаг 2
    let s1 = String::from("первый");
    let s2 = String::from("второй");
    let s3 = String::from("третий");
    
    // Шаг 3
    v.push(s1);
    
    // Шаг 4
    // println!("s1: {}", s1); // Ошибка: значение перемещено
    
    // Шаг 5
    v.push(s2);
    v.push(s3.clone());
    
    // Шаг 6
    println!("s3: {}", s3); // Работает, потому что мы использовали clone()
    
    // Шаг 7
    for s in &v {
        println!("{}", s);
    }
    
    // Шаг 8
    for s in v {
        println!("{}", s);
    }
    
    // Шаг 9
    // println!("{:?}", v); // Ошибка: значение перемещено
}
```

### Анализ:

1. **Шаг 1**: Создается пустой вектор `v`.
2. **Шаг 2**: Создаются три строки: `s1`, `s2` и `s3`.
3. **Шаг 3**: Строка `s1` перемещается в вектор `v`. Теперь `v` владеет этой строкой.
4. **Шаг 4**: Попытка использовать `s1` приведет к ошибке компиляции, потому что значение было перемещено.
5. **Шаг 5**: Строка `s2` перемещается в вектор `v`. Клон строки `s3` перемещается в вектор `v`. Оригинал `s3` остается действительным.
6. **Шаг 6**: Выводится значение `s3`. Это работает, потому что мы использовали `clone()`.
7. **Шаг 7**: Итерация по ссылкам на элементы вектора. Вектор `v` остается действительным.
8. **Шаг 8**: Итерация по элементам вектора с перемещением. Вектор `v` становится недействительным, потому что его элементы перемещаются в цикле.
9. **Шаг 9**: Попытка использовать `v` приведет к ошибке компиляции, потому что значение было перемещено.

## Упражнение 4: Работа с вектором без перемещения

Измените последнюю часть предыдущего примера так, чтобы вектор `v` оставался действительным после цикла.

### Решение:

```rust
fn main() {
    let mut v = Vec::new();
    
    let s1 = String::from("первый");
    let s2 = String::from("второй");
    let s3 = String::from("третий");
    
    v.push(s1);
    v.push(s2);
    v.push(s3.clone());
    
    println!("s3: {}", s3);
    
    // Используем ссылки, чтобы не перемещать элементы
    for s in &v {
        println!("{}", s);
    }
    
    // Вектор v все еще действителен
    println!("Количество элементов в векторе: {}", v.len());
    println!("Первый элемент: {}", v[0]);
}
```

## Пример 5: Отслеживание владения в замыканиях

Рассмотрим пример с замыканием, которое захватывает переменные:

```rust
fn main() {
    // Шаг 1
    let x = 10;
    let s = String::from("привет");
    
    // Шаг 2: Замыкание, которое захватывает x по ссылке
    let f = |y| x + y;
    
    // Шаг 3
    println!("f(5) = {}", f(5));
    println!("x = {}", x); // x все еще действителен
    
    // Шаг 4: Замыкание, которое захватывает s по значению (с перемещением)
    let g = move || {
        println!("s = {}", s);
    };
    
    // Шаг 5
    g();
    
    // Шаг 6
    // println!("s = {}", s); // Ошибка: значение перемещено
}
```

### Анализ:

1. **Шаг 1**: Создаются переменные `x` и `s`.
2. **Шаг 2**: Создается замыкание `f`, которое захватывает `x` по ссылке.
3. **Шаг 3**: Вызывается замыкание `f`. Переменная `x` остается действительной, потому что она была захвачена по ссылке.
4. **Шаг 4**: Создается замыкание `g` с ключевым словом `move`, которое захватывает `s` по значению (с перемещением).
5. **Шаг 5**: Вызывается замыкание `g`.
6. **Шаг 6**: Попытка использовать `s` приведет к ошибке компиляции, потому что значение было перемещено в замыкание.

## Упражнение 5: Создание замыкания без перемещения

Измените предыдущий пример так, чтобы переменная `s` оставалась действительной после создания и вызова замыкания.

### Решение:

```rust
fn main() {
    let x = 10;
    let s = String::from("привет");
    
    // Замыкание, которое захватывает s по ссылке
    let g = || {
        println!("s = {}", s);
    };
    
    g();
    
    // s все еще действителен
    println!("s = {}", s);
}
```

## Пример 6: Отслеживание владения в многопоточном коде

Рассмотрим пример с созданием потока:

```rust
use std::thread;

fn main() {
    // Шаг 1
    let v = vec![1, 2, 3];
    
    // Шаг 2
    let handle = thread::spawn(move || {
        println!("Вектор в потоке: {:?}", v);
    });
    
    // Шаг 3
    // println!("Вектор в main: {:?}", v); // Ошибка: значение перемещено
    
    // Шаг 4
    handle.join().unwrap();
}
```

### Анализ:

1. **Шаг 1**: Создается вектор `v`.
2. **Шаг 2**: Создается новый поток с замыканием, которое захватывает `v` по значению (с перемещением). Владение вектором перемещается в поток.
3. **Шаг 3**: Попытка использовать `v` в основном потоке приведет к ошибке компиляции, потому что значение было перемещено.
4. **Шаг 4**: Основной поток ожидает завершения созданного потока.

## Упражнение 6: Многопоточный код с клонированием

Измените предыдущий пример так, чтобы вектор `v` оставался действительным в основном потоке.

### Решение:

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];
    
    // Клонируем вектор для потока
    let v_clone = v.clone();
    
    let handle = thread::spawn(move || {
        println!("Вектор в потоке: {:?}", v_clone);
    });
    
    // v все еще действителен в основном потоке
    println!("Вектор в main: {:?}", v);
    
    handle.join().unwrap();
}
```

## Пример 7: Комплексный пример с различными типами данных

Рассмотрим более сложный пример, который включает различные типы данных и операции:

```rust
struct User {
    name: String,
    email: String,
    active: bool,
}

fn main() {
    // Шаг 1: Создание структуры
    let user1 = User {
        name: String::from("Алиса"),
        email: String::from("alice@example.com"),
        active: true,
    };
    
    // Шаг 2: Создание вектора целых чисел
    let numbers = vec![1, 2, 3, 4, 5];
    
    // Шаг 3: Создание строки
    let message = String::from("Привет, мир!");
    
    // Шаг 4: Вызов функции, которая принимает владение структурой
    let (name, active) = process_user(user1);
    
    // Шаг 5: Вызов функции, которая принимает ссылку на вектор
    let sum = sum_numbers(&numbers);
    
    // Шаг 6: Вызов функции, которая принимает владение строкой
    let new_message = add_exclamation(message);
    
    // Шаг 7: Вывод результатов
    println!("Имя: {}, Активен: {}", name, active);
    println!("Сумма чисел: {}", sum);
    println!("Новое сообщение: {}", new_message);
    
    // Шаг 8: Попытка использовать перемещенные значения
    // println!("Email: {}", user1.email); // Ошибка: значение перемещено
    // println!("Старое сообщение: {}", message); // Ошибка: значение перемещено
    
    // Шаг 9: Использование значений, которые не были перемещены
    println!("Числа: {:?}", numbers); // Работает, потому что мы передали ссылку
}

fn process_user(user: User) -> (String, bool) {
    println!("Обработка пользователя: {}", user.name);
    (user.name, user.active)
}

fn sum_numbers(numbers: &Vec<i32>) -> i32 {
    numbers.iter().sum()
}

fn add_exclamation(mut message: String) -> String {
    message.push_str("!");
    message
}
```

### Анализ:

1. **Шаг 1**: Создается структура `user1`.
2. **Шаг 2**: Создается вектор `numbers`.
3. **Шаг 3**: Создается строка `message`.
4. **Шаг 4**: Вызывается функция `process_user`, которая принимает владение структурой `user1`. Функция возвращает кортеж, содержащий имя и статус активности.
5. **Шаг 5**: Вызывается функция `sum_numbers`, которая принимает ссылку на вектор `numbers`. Вектор остается действительным.
6. **Шаг 6**: Вызывается функция `add_exclamation`, которая принимает владение строкой `message`. Функция возвращает новую строку.
7. **Шаг 7**: Выводятся результаты.
8. **Шаг 8**: Попытка использовать перемещенные значения приведет к ошибке компиляции.
9. **Шаг 9**: Используются значения, которые не были перемещены.

## Упражнение 7: Комплексная задача

Напишите программу, которая:
1. Создает структуру `Book` с полями `title` (String), `author` (String) и `year` (u32).
2. Создает вектор книг.
3. Реализует функцию, которая принимает ссылку на вектор книг и возвращает количество книг, опубликованных после определенного года.
4. Реализует функцию, которая принимает владение книгой и возвращает строку в формате "Название (Автор, Год)".
5. Использует обе функции и выводит результаты.

### Решение:

```rust
struct Book {
    title: String,
    author: String,
    year: u32,
}

fn count_books_after_year(books: &Vec<Book>, year: u32) -> usize {
    books.iter().filter(|book| book.year > year).count()
}

fn format_book(book: Book) -> String {
    format!("{} ({}, {})", book.title, book.author, book.year)
}

fn main() {
    // Создаем вектор книг
    let mut books = Vec::new();
    
    books.push(Book {
        title: String::from("1984"),
        author: String::from("Джордж Оруэлл"),
        year: 1949,
    });
    
    books.push(Book {
        title: String::from("Гарри Поттер и философский камень"),
        author: String::from("Дж. К. Роулинг"),
        year: 1997,
    });
    
    books.push(Book {
        title: String::from("Мастер и Маргарита"),
        author: String::from("Михаил Булгаков"),
        year: 1967,
    });
    
    // Подсчитываем книги, опубликованные после 1970 года
    let count = count_books_after_year(&books, 1970);
    println!("Количество книг после 1970 года: {}", count);
    
    // Форматируем и выводим информацию о первой книге
    // Используем clone(), чтобы не перемещать книгу из вектора
    let formatted = format_book(books[0].clone());
    println!("Форматированная информация: {}", formatted);
    
    // Книги все еще доступны
    println!("Всего книг: {}", books.len());
    
    // Можно также переместить книгу из вектора, если она больше не нужна
    let last_book = books.pop().unwrap();
    let formatted_last = format_book(last_book);
    println!("Последняя книга: {}", formatted_last);
    
    // Теперь в векторе на одну книгу меньше
    println!("Осталось книг: {}", books.len());
}
```

## Заключение

В этой практической теме мы рассмотрели различные аспекты системы владения в Rust на конкретных примерах. Мы научились:

1. Отслеживать владение переменными в простых программах.
2. Исправлять ошибки, связанные с перемещением значений.
3. Использовать клонирование для создания копий данных.
4. Работать с функциями, которые принимают и возвращают владение.
5. Управлять владением в структурах и векторах.
6. Использовать замыкания с захватом переменных.
7. Работать с многопоточным кодом, учитывая особенности системы владения.

Понимание системы владения и умение отслеживать владение в программах - это ключевые навыки для эффективного программирования на Rust. Практикуйтесь в анализе и написании кода, обращая внимание на то, как перемещается владение между переменными и функциями.