# Комментарии и документация в Rust

## Введение

Комментарии и документация являются важной частью любого программного кода. Они помогают разработчикам понять, как работает код, и облегчают его поддержку и развитие. В Rust существует несколько типов комментариев, а также мощная система документации, которая интегрирована с языком.

В этой главе мы рассмотрим:
- Однострочные комментарии
- Многострочные комментарии
- Документационные комментарии
- Специальные теги документации
- Генерацию документации с помощью rustdoc
- Лучшие практики документирования

## Типы комментариев

### Однострочные комментарии

Однострочные комментарии в Rust начинаются с двух слешей (`//`) и продолжаются до конца строки. Они игнорируются компилятором и служат только для пояснения кода для разработчиков.

```rust
fn main() {
    // Это однострочный комментарий
    let x = 5; // Комментарий может быть и в конце строки кода
    
    // Комментарии могут занимать отдельные строки
    // и могут быть сгруппированы для более длинных пояснений
    let y = 10;
}
```

Однострочные комментарии часто используются для:
- Краткого объяснения сложных частей кода
- Временного отключения части кода (комментирование кода)
- Пометок для будущих изменений (TODO, FIXME и т.д.)

### Многострочные комментарии

Многострочные комментарии в Rust начинаются с `/*` и заканчиваются `*/`. Всё, что находится между этими символами, игнорируется компилятором.

```rust
fn main() {
    /* Это многострочный комментарий.
       Он может занимать несколько строк
       и часто используется для более подробных пояснений. */
    
    let x = /* даже внутри выражений */ 5;
    
    /*
     * Некоторые разработчики предпочитают добавлять звездочку
     * в начале каждой строки многострочного комментария
     * для лучшей читаемости.
     */
}
```

Многострочные комментарии менее распространены в Rust, чем однострочные, но они могут быть полезны в следующих случаях:
- Временное отключение больших блоков кода
- Подробное объяснение сложных алгоритмов
- Комментирование внутри выражений

### Документационные комментарии

Документационные комментарии в Rust — это особый тип комментариев, которые используются для генерации документации. Они начинаются с трех слешей (`///`) для документирования следующего за ними элемента или с `//!` для документирования содержащего их элемента (обычно модуля или крейта).

```rust
/// Вычисляет факториал числа.
///
/// # Примеры
///
/// ```
/// let result = factorial(5);
/// assert_eq!(result, 120);
/// ```
fn factorial(n: u64) -> u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}

//! # Модуль математических функций
//!
//! Этот модуль содержит различные математические функции.
```

Документационные комментарии поддерживают Markdown, что позволяет форматировать текст, добавлять списки, таблицы, ссылки и другие элементы форматирования.

## Документирование различных элементов

### Документирование функций

Функции обычно документируются с помощью `///` перед их объявлением. Хорошая документация функции должна включать:
- Краткое описание того, что делает функция
- Описание параметров
- Описание возвращаемого значения
- Примеры использования
- Возможные ошибки или исключения

```rust
/// Вычисляет сумму двух чисел.
///
/// # Параметры
///
/// * `a` - Первое слагаемое
/// * `b` - Второе слагаемое
///
/// # Возвращаемое значение
///
/// Сумма `a` и `b`
///
/// # Примеры
///
/// ```
/// let sum = add(2, 3);
/// assert_eq!(sum, 5);
/// ```
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### Документирование модулей

Модули документируются с помощью `//!` в начале файла модуля. Документация модуля обычно включает:
- Общее описание модуля
- Обзор основных функций и типов
- Примеры использования
- Связи с другими модулями

```rust
//! # Модуль обработки строк
//!
//! Этот модуль предоставляет функции для работы со строками,
//! включая форматирование, поиск и замену.
//!
//! ## Основные функции
//!
//! * `format_string` - Форматирует строку по заданному шаблону
//! * `find_substring` - Ищет подстроку в строке
//! * `replace_substring` - Заменяет подстроку в строке
//!
//! ## Примеры
//!
//! ```
//! let formatted = string_utils::format_string("Hello, {}!", "world");
//! assert_eq!(formatted, "Hello, world!");
//! ```

/// Форматирует строку по заданному шаблону.
pub fn format_string(template: &str, value: &str) -> String {
    template.replace("{}", value)
}

/// Ищет подстроку в строке.
pub fn find_substring(string: &str, substring: &str) -> Option<usize> {
    string.find(substring)
}

/// Заменяет подстроку в строке.
pub fn replace_substring(string: &str, from: &str, to: &str) -> String {
    string.replace(from, to)
}
```

### Документирование структур и их методов

Структуры и их методы также документируются с помощью `///`. Документация структуры обычно включает:
- Описание назначения структуры
- Описание полей
- Примеры создания и использования

```rust
/// Представляет точку в двумерном пространстве.
///
/// # Поля
///
/// * `x` - Координата по оси X
/// * `y` - Координата по оси Y
///
/// # Примеры
///
/// ```
/// let point = Point { x: 1.0, y: 2.0 };
/// assert_eq!(point.distance_from_origin(), 2.236);
/// ```
pub struct Point {
    /// Координата по оси X
    pub x: f64,
    /// Координата по оси Y
    pub y: f64,
}

impl Point {
    /// Создает новую точку с заданными координатами.
    ///
    /// # Параметры
    ///
    /// * `x` - Координата по оси X
    /// * `y` - Координата по оси Y
    ///
    /// # Возвращаемое значение
    ///
    /// Новый экземпляр `Point`
    pub fn new(x: f64, y: f64) -> Point {
        Point { x, y }
    }
    
    /// Вычисляет расстояние от точки до начала координат.
    ///
    /// # Возвращаемое значение
    ///
    /// Расстояние до начала координат
    pub fn distance_from_origin(&self) -> f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

### Документирование перечислений

Перечисления (enums) документируются аналогично структурам. Документация перечисления обычно включает:
- Описание назначения перечисления
- Описание вариантов
- Примеры использования

```rust
/// Представляет результат операции, которая может завершиться ошибкой.
///
/// # Варианты
///
/// * `Success` - Операция завершилась успешно, содержит результат
/// * `Error` - Операция завершилась с ошибкой, содержит сообщение об ошибке
///
/// # Примеры
///
/// ```
/// let result = divide(10, 2);
/// assert_eq!(result, OperationResult::Success(5));
///
/// let result = divide(10, 0);
/// assert!(matches!(result, OperationResult::Error(_)));
/// ```
pub enum OperationResult<T> {
    /// Операция завершилась успешно
    Success(T),
    /// Операция завершилась с ошибкой
    Error(String),
}

/// Делит одно число на другое.
///
/// # Параметры
///
/// * `a` - Делимое
/// * `b` - Делитель
///
/// # Возвращаемое значение
///
/// `OperationResult::Success` с результатом деления, если `b` не равно 0,
/// или `OperationResult::Error` с сообщением об ошибке в противном случае.
pub fn divide(a: i32, b: i32) -> OperationResult<i32> {
    if b == 0 {
        OperationResult::Error("Деление на ноль".to_string())
    } else {
        OperationResult::Success(a / b)
    }
}
```

## Специальные теги документации

Rust поддерживает несколько специальных тегов в документационных комментариях, которые помогают структурировать документацию:

- `# Examples` - Примеры использования
- `# Panics` - Описание ситуаций, когда функция может вызвать панику
- `# Errors` - Описание возможных ошибок
- `# Safety` - Информация о безопасности (для небезопасных функций)
- `# Parameters` - Описание параметров
- `# Returns` - Описание возвращаемого значения
- `# See also` - Ссылки на связанные функции или модули

```rust
/// Извлекает элемент из вектора по индексу.
///
/// # Параметры
///
/// * `vec` - Вектор, из которого извлекается элемент
/// * `index` - Индекс элемента
///
/// # Возвращаемое значение
///
/// Элемент по указанному индексу
///
/// # Panics
///
/// Функция вызывает панику, если `index` выходит за границы вектора.
///
/// # Примеры
///
/// ```
/// let v = vec![1, 2, 3];
/// let third = get_element(&v, 2);
/// assert_eq!(third, 3);
/// ```
///
/// # См. также
///
/// * [`Vec::get`] - Безопасная альтернатива, возвращающая `Option`
pub fn get_element<T: Clone>(vec: &Vec<T>, index: usize) -> T {
    vec[index].clone()
}
```

### Примеры кода в документации

Примеры кода в документации Rust не только помогают пользователям понять, как использовать функцию или тип, но и могут быть автоматически проверены как тесты с помощью команды `cargo test`.

Примеры кода должны быть заключены в тройные обратные кавычки (``` ```). По умолчанию предполагается, что это код на Rust, но можно указать и другой язык.

```rust
/// Вычисляет факториал числа.
///
/// # Примеры
///
/// Базовый пример:
///
/// ```
/// let result = factorial(5);
/// assert_eq!(result, 120);
/// ```
///
/// Граничный случай:
///
/// ```
/// let result = factorial(0);
/// assert_eq!(result, 1);
/// ```
///
/// # Panics
///
/// Функция может вызвать панику при переполнении для больших значений `n`.
pub fn factorial(n: u64) -> u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}
```

### Тестирование примеров в документации

Когда вы запускаете `cargo test`, Rust автоматически извлекает примеры кода из документации и запускает их как тесты. Это гарантирует, что примеры в документации всегда актуальны и работают с текущей версией кода.

Если вы хотите включить пример кода, который не должен выполняться как тест, вы можете использовать атрибут `ignore`:

```rust
/// ```ignore
/// // Этот код не будет выполняться как тест
/// let x = некорректный_синтаксис;
/// ```
```

Или, если вы хотите показать пример, который должен вызвать ошибку компиляции:

```rust
/// ```compile_fail
/// // Этот код должен вызвать ошибку компиляции
/// let x: i32 = "строка"; // Ошибка типа
/// ```
```

## Генерация документации с помощью rustdoc

Rust предоставляет инструмент `rustdoc` для генерации HTML-документации из документационных комментариев. Обычно он вызывается через Cargo:

```bash
cargo doc
```

Эта команда генерирует HTML-документацию для вашего проекта и всех его зависимостей. Документация сохраняется в директории `target/doc`.

Чтобы открыть документацию в браузере, вы можете использовать:

```bash
cargo doc --open
```

Для генерации документации только для вашего проекта, без зависимостей:

```bash
cargo doc --no-deps
```

## Лучшие практики документирования

1. **Документируйте публичный API**: Все публичные функции, типы, модули и методы должны иметь документацию.

2. **Включайте примеры**: Примеры помогают пользователям понять, как использовать ваш код.

3. **Описывайте параметры и возвращаемые значения**: Четко указывайте, что принимает функция и что она возвращает.

4. **Указывайте возможные ошибки и исключения**: Если функция может вызвать панику или вернуть ошибку, документируйте эти случаи.

5. **Используйте Markdown для форматирования**: Markdown делает документацию более читаемой.

6. **Поддерживайте документацию в актуальном состоянии**: Обновляйте документацию при изменении кода.

7. **Проверяйте примеры**: Убедитесь, что примеры в документации работают, запуская `cargo test`.

8. **Используйте специальные теги**: Теги, такие как `# Examples`, `# Panics`, помогают структурировать документацию.

## Примеры хорошо документированного кода

### Пример 1: Документирование библиотечного модуля

```rust
//! # Модуль обработки конфигурации
//!
//! Этот модуль предоставляет функции для загрузки, проверки и сохранения
//! конфигурационных файлов в различных форматах (JSON, YAML, TOML).
//!
//! ## Основные функции
//!
//! * [`load_config`] - Загружает конфигурацию из файла
//! * [`save_config`] - Сохраняет конфигурацию в файл
//! * [`validate_config`] - Проверяет конфигурацию на корректность
//!
//! ## Примеры
//!
//! ```
//! use config::{load_config, ConfigFormat};
//!
//! let config = load_config("config.json", ConfigFormat::Json).unwrap();
//! println!("Loaded config: {:?}", config);
//! ```

/// Формат конфигурационного файла.
///
/// Поддерживаются форматы JSON, YAML и TOML.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConfigFormat {
    /// Формат JSON
    Json,
    /// Формат YAML
    Yaml,
    /// Формат TOML
    Toml,
}

/// Загружает конфигурацию из файла.
///
/// # Параметры
///
/// * `path` - Путь к конфигурационному файлу
/// * `format` - Формат конфигурационного файла
///
/// # Возвращаемое значение
///
/// В случае успеха возвращает загруженную конфигурацию.
/// В случае ошибки возвращает описание ошибки.
///
/// # Примеры
///
/// ```
/// use config::{load_config, ConfigFormat};
///
/// let result = load_config("config.json", ConfigFormat::Json);
/// match result {
///     Ok(config) => println!("Конфигурация загружена: {:?}", config),
///     Err(err) => eprintln!("Ошибка загрузки конфигурации: {}", err),
/// }
/// ```
///
/// # Ошибки
///
/// Функция может вернуть ошибку в следующих случаях:
///
/// * Файл не существует или недоступен для чтения
/// * Содержимое файла не соответствует указанному формату
/// * Конфигурация не проходит валидацию
pub fn load_config(path: &str, format: ConfigFormat) -> Result<Config, String> {
    // Реализация функции...
    unimplemented!()
}

/// Структура конфигурации.
///
/// Содержит все настройки приложения.
///
/// # Поля
///
/// * `name` - Название приложения
/// * `version` - Версия приложения
/// * `settings` - Дополнительные настройки
///
/// # Примеры
///
/// ```
/// let config = Config {
///     name: "MyApp".to_string(),
///     version: "1.0.0".to_string(),
///     settings: HashMap::new(),
/// };
/// ```
pub struct Config {
    /// Название приложения
    pub name: String,
    /// Версия приложения
    pub version: String,
    /// Дополнительные настройки
    pub settings: std::collections::HashMap<String, String>,
}
```

### Пример 2: Документирование алгоритма

```rust
/// Выполняет бинарный поиск в отсортированном массиве.
///
/// # Алгоритм
///
/// Бинарный поиск работает путем деления отсортированного массива пополам
/// и определения, в какой половине может находиться искомый элемент.
/// Этот процесс повторяется до тех пор, пока элемент не будет найден
/// или не станет ясно, что элемент отсутствует в массиве.
///
/// # Параметры
///
/// * `arr` - Отсортированный массив, в котором выполняется поиск
/// * `target` - Искомое значение
///
/// # Возвращаемое значение
///
/// Если элемент найден, возвращает `Some(index)`, где `index` - индекс элемента.
/// Если элемент не найден, возвращает `None`.
///
/// # Сложность
///
/// * Временная сложность: O(log n)
/// * Пространственная сложность: O(1)
///
/// # Примеры
///
/// ```
/// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
/// let index = binary_search(&arr, 7);
/// assert_eq!(index, Some(6));
///
/// let index = binary_search(&arr, 11);
/// assert_eq!(index, None);
/// ```
pub fn binary_search<T: Ord>(arr: &[T], target: T) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();
    
    while left < right {
        let mid = left + (right - left) / 2;
        
        if arr[mid] == target {
            return Some(mid);
        } else if arr[mid] < target {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    None
}
```

## Упражнения

1. **Документирование функции**:
   Напишите функцию, которая вычисляет среднее значение массива чисел, и добавьте к ней полную документацию, включая примеры, описание параметров и возвращаемого значения.

2. **Документирование структуры**:
   Создайте структуру `Person` с полями `name`, `age` и `email`, а также методы для работы с этой структурой. Добавьте полную документацию к структуре и её методам.

3. **Документирование модуля**:
   Создайте модуль `geometry` с функциями для вычисления площади и периметра различных геометрических фигур. Добавьте документацию к модулю и всем его функциям.

4. **Генерация и просмотр документации**:
   Создайте небольшой проект с документированным кодом, сгенерируйте документацию с помощью `cargo doc` и просмотрите её в браузере.

## Заключение

Комментарии и документация являются важной частью разработки на Rust. Они помогают другим разработчикам (и вам самим в будущем) понять, как работает ваш код, и как его использовать.

Rust предоставляет мощные инструменты для документирования кода, включая документационные комментарии с поддержкой Markdown, автоматическое тестирование примеров и генерацию HTML-документации.

Следуя лучшим практикам документирования, вы сделаете свой код более доступным и понятным для других разработчиков, что особенно важно для библиотек и открытых проектов.

В следующей главе мы рассмотрим операторы и выражения в Rust, что позволит нам создавать более сложные и функциональные программы.