# Модули и области видимости

Модули в Rust позволяют организовывать код в логические группы, управлять областями видимости и контролировать доступ к элементам кода. Они являются ключевым инструментом для создания хорошо структурированных и поддерживаемых программ.

## Основы модульной системы

Модульная система Rust помогает решить несколько важных задач:

1. **Организация кода**: Группировка связанных функций, структур и других элементов.
2. **Контроль доступа**: Определение, какие элементы доступны извне модуля (публичные), а какие нет (приватные).
3. **Управление пространством имен**: Предотвращение конфликтов имен между различными частями программы.

## Создание модулей

### Модули в одном файле

Самый простой способ создать модуль - использовать ключевое слово `mod`:

```rust
// Определение модуля
mod math {
    // Содержимое модуля
    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    
    pub fn subtract(a: i32, b: i32) -> i32 {
        a - b
    }
    
    // Приватная функция, доступная только внутри модуля
    fn helper() {
        println!("Это вспомогательная функция");
    }
}

fn main() {
    // Использование функций из модуля
    let sum = math::add(5, 3);
    let difference = math::subtract(10, 4);
    
    println!("Сумма: {}", sum);
    println!("Разность: {}", difference);
    
    // Следующая строка вызовет ошибку компиляции, так как helper - приватная функция
    // math::helper();
}
```

### Вложенные модули

Модули могут быть вложенными друг в друга, образуя иерархию:

```rust
mod physics {
    pub mod motion {
        pub fn calculate_velocity(distance: f64, time: f64) -> f64 {
            distance / time
        }
        
        pub fn calculate_acceleration(velocity: f64, time: f64) -> f64 {
            velocity / time
        }
    }
    
    pub mod thermodynamics {
        pub fn celsius_to_fahrenheit(celsius: f64) -> f64 {
            celsius * 9.0 / 5.0 + 32.0
        }
        
        pub fn fahrenheit_to_celsius(fahrenheit: f64) -> f64 {
            (fahrenheit - 32.0) * 5.0 / 9.0
        }
    }
}

fn main() {
    // Использование функций из вложенных модулей
    let velocity = physics::motion::calculate_velocity(100.0, 10.0);
    let fahrenheit = physics::thermodynamics::celsius_to_fahrenheit(25.0);
    
    println!("Скорость: {} м/с", velocity);
    println!("Температура: {} °F", fahrenheit);
}
```

### Модули в отдельных файлах

Для более крупных проектов удобно размещать модули в отдельных файлах. Рассмотрим пример структуры проекта:

```
src/
├── main.rs
└── math.rs
```

Содержимое файла `math.rs`:

```rust
// math.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}

fn helper() {
    println!("Это вспомогательная функция");
}
```

Содержимое файла `main.rs`:

```rust
// main.rs
// Подключаем модуль math из файла math.rs
mod math;

fn main() {
    let sum = math::add(5, 3);
    let difference = math::subtract(10, 4);
    
    println!("Сумма: {}", sum);
    println!("Разность: {}", difference);
}
```

### Модули в директориях

Для еще более сложных проектов модули можно организовывать в директории. Рассмотрим пример:

```
src/
├── main.rs
└── physics/
    ├── mod.rs
    ├── motion.rs
    └── thermodynamics.rs
```

Содержимое файла `physics/mod.rs`:

```rust
// physics/mod.rs
// Объявляем подмодули
pub mod motion;
pub mod thermodynamics;
```

Содержимое файла `physics/motion.rs`:

```rust
// physics/motion.rs
pub fn calculate_velocity(distance: f64, time: f64) -> f64 {
    distance / time
}

pub fn calculate_acceleration(velocity: f64, time: f64) -> f64 {
    velocity / time
}
```

Содержимое файла `physics/thermodynamics.rs`:

```rust
// physics/thermodynamics.rs
pub fn celsius_to_fahrenheit(celsius: f64) -> f64 {
    celsius * 9.0 / 5.0 + 32.0
}

pub fn fahrenheit_to_celsius(fahrenheit: f64) -> f64 {
    (fahrenheit - 32.0) * 5.0 / 9.0
}
```

Содержимое файла `main.rs`:

```rust
// main.rs
// Подключаем модуль physics
mod physics;

fn main() {
    let velocity = physics::motion::calculate_velocity(100.0, 10.0);
    let fahrenheit = physics::thermodynamics::celsius_to_fahrenheit(25.0);
    
    println!("Скорость: {} м/с", velocity);
    println!("Температура: {} °F", fahrenheit);
}
```

## Области видимости и контроль доступа

### Приватные и публичные элементы

По умолчанию все элементы в Rust (функции, структуры, перечисления и т.д.) являются приватными и доступны только внутри модуля, в котором они определены. Чтобы сделать элемент доступным извне, нужно использовать ключевое слово `pub`.

### Правила доступа для структур и перечислений

1. Если структура публичная (`pub struct`), ее поля все равно остаются приватными по умолчанию.
2. Если перечисление публичное (`pub enum`), все его варианты автоматически становятся публичными.

## Использование модулей

### Ключевое слово use

Для удобства использования элементов из модулей можно использовать ключевое слово `use`, которое позволяет импортировать элементы в текущую область видимости.

### Псевдонимы с as

Можно создавать псевдонимы для импортируемых элементов с помощью ключевого слова `as`.

### Реэкспорт с pub use

Можно реэкспортировать элементы из одного модуля в другой с помощью `pub use`.

## Пути в модульной системе

### Абсолютные и относительные пути

В Rust можно использовать абсолютные и относительные пути для доступа к элементам модулей.

### Ключевые слова self, super и crate

- `self` - ссылается на текущий модуль
- `super` - ссылается на родительский модуль
- `crate` - ссылается на корень текущего крейта

## Области видимости

### Лексические области видимости

В Rust области видимости определяются блоками кода, ограниченными фигурными скобками `{}`.

### Затенение переменных

В Rust можно объявлять переменные с одинаковыми именами в разных областях видимости, при этом внутренняя переменная "затеняет" внешнюю.

### Области видимости и время жизни

Области видимости тесно связаны с концепцией времени жизни в Rust.

## Заключение

Модули и области видимости в Rust предоставляют мощные инструменты для организации кода, контроля доступа и управления пространством имен. Правильное использование модульной системы позволяет создавать хорошо структурированные, поддерживаемые и масштабируемые программы.

Ключевые моменты:
- Модули помогают организовать код в логические группы
- Ключевое слово `pub` контролирует доступ к элементам
- Ключевое слово `use` упрощает использование элементов из модулей
- Области видимости определяют, где переменные и другие элементы доступны
