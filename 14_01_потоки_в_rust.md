# Потоки в Rust

## Введение в многопоточное программирование

Многопоточное программирование позволяет выполнять несколько задач одновременно, что может значительно повысить производительность программы, особенно на современных многоядерных процессорах. Rust предоставляет надежные инструменты для работы с потоками, которые помогают избежать распространенных проблем, таких как гонки данных и взаимные блокировки.

## Создание потоков

В Rust потоки реализованы в стандартной библиотеке через модуль `std::thread`. Для создания нового потока используется функция `thread::spawn`, которая принимает замыкание (closure) с кодом, который будет выполняться в новом потоке.

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // Создаем новый поток
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("Привет из потока! Счетчик: {}", i);
            thread::sleep(Duration::from_millis(500));
        }
    });

    // Код в основном потоке продолжает выполняться
    for i in 1..5 {
        println!("Привет из основного потока! Счетчик: {}", i);
        thread::sleep(Duration::from_millis(1000));
    }

    // Ожидаем завершения дочернего потока
    handle.join().unwrap();
}
```

В этом примере:
1. Мы создаем новый поток с помощью `thread::spawn`.
2. Функция возвращает `JoinHandle`, который мы сохраняем в переменной `handle`.
3. Основной поток продолжает выполнение параллельно с новым потоком.
4. Метод `join()` блокирует основной поток до завершения дочернего потока.

## Ожидание завершения потоков

Метод `join()` на `JoinHandle` позволяет дождаться завершения потока. Он возвращает `Result`, который содержит либо возвращаемое значение потока, либо ошибку, если поток запаниковал.

```rust
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        // Возвращаем значение из потока
        42
    });

    // Ожидаем завершения потока и получаем результат
    match handle.join() {
        Ok(value) => println!("Поток вернул: {}", value),
        Err(_) => println!("Поток запаниковал!"),
    }
}
```

## Передача данных в поток

Чтобы передать данные в поток, мы можем использовать замыкание, которое захватывает переменные из окружения. Однако, из-за системы владения Rust, нам нужно явно указать, что мы хотим переместить значение в поток с помощью ключевого слова `move`.

```rust
use std::thread;

fn main() {
    let data = vec![1, 2, 3];
    
    // Используем move, чтобы переместить владение data в поток
    let handle = thread::spawn(move || {
        println!("Данные в потоке: {:?}", data);
    });
    
    // Здесь data уже недоступна, так как владение перешло в поток
    // println!("Данные в основном потоке: {:?}", data); // Ошибка компиляции!
    
    handle.join().unwrap();
}
```

## Жизненный цикл потоков

Потоки в Rust имеют следующий жизненный цикл:

1. **Создание**: Поток создается с помощью `thread::spawn`.
2. **Выполнение**: Код в потоке выполняется параллельно с основным потоком.
3. **Завершение**: Поток завершается, когда:
   - Выполнение кода в замыкании завершается
   - Происходит паника в потоке
   - Программа завершается (все потоки принудительно завершаются)

## Настройка потоков

Rust позволяет настраивать параметры потоков с помощью `thread::Builder`:

```rust
use std::thread;

fn main() {
    let builder = thread::Builder::new()
        .name("my-thread".to_string()) // Задаем имя потока
        .stack_size(32 * 1024); // Задаем размер стека (32 КБ)
    
    let handle = builder.spawn(|| {
        println!("Привет из настроенного потока!");
        println!("Имя текущего потока: {:?}", thread::current().name());
    }).unwrap();
    
    handle.join().unwrap();
}
```

## Локальное хранилище потока (Thread Local Storage)

Rust предоставляет возможность создавать переменные, которые уникальны для каждого потока, с помощью макроса `thread_local!`:

```rust
use std::cell::RefCell;
use std::thread;

thread_local! {
    static COUNTER: RefCell<u32> = RefCell::new(0);
}

fn main() {
    // Увеличиваем счетчик в основном потоке
    COUNTER.with(|c| {
        *c.borrow_mut() += 1;
        println!("Счетчик в основном потоке: {}", *c.borrow());
    });
    
    // Создаем новый поток
    let handle = thread::spawn(|| {
        // У нового потока будет свой собственный счетчик
        COUNTER.with(|c| {
            *c.borrow_mut() += 1;
            println!("Счетчик в дочернем потоке: {}", *c.borrow());
        });
    });
    
    handle.join().unwrap();
    
    // Счетчик в основном потоке не изменился
    COUNTER.with(|c| {
        println!("Счетчик в основном потоке после завершения дочернего: {}", *c.borrow());
    });
}
```

## Обработка паники в потоках

Если в потоке происходит паника, она не распространяется на другие потоки. Вместо этого поток завершается, и метод `join()` возвращает `Err`:

```rust
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        panic!("Ой, что-то пошло не так!");
    });
    
    match handle.join() {
        Ok(_) => println!("Поток завершился успешно"),
        Err(e) => println!("Поток запаниковал: {:?}", e),
    }
}
```

## Преимущества и ограничения потоков в Rust

### Преимущества:
- **Безопасность**: Система владения и заимствования Rust предотвращает многие распространенные ошибки многопоточного программирования на этапе компиляции.
- **Производительность**: Потоки в Rust — это нативные потоки операционной системы, что обеспечивает хорошую производительность.
- **Контроль**: Rust предоставляет низкоуровневый контроль над потоками, позволяя настраивать их параметры.

### Ограничения:
- **Накладные расходы**: Создание потока имеет накладные расходы, поэтому для большого количества мелких задач лучше использовать пул потоков.
- **Сложность**: Многопоточное программирование по своей природе сложнее, чем однопоточное, даже с гарантиями безопасности Rust.

## Когда использовать потоки

Потоки в Rust лучше всего подходят для:
- Параллельной обработки независимых данных
- Фоновых задач, которые должны выполняться параллельно с основным потоком
- Задач, которые могут блокировать выполнение (например, I/O операции)

Для более сложных сценариев многопоточности, таких как пулы потоков или асинхронное программирование, Rust предлагает дополнительные библиотеки и абстракции, которые мы рассмотрим в следующих разделах.

## Заключение

Потоки в Rust предоставляют мощный инструмент для параллельного выполнения кода. Благодаря системе владения и заимствования, Rust помогает избежать многих распространенных ошибок многопоточного программирования на этапе компиляции. В следующих разделах мы рассмотрим, как безопасно передавать данные между потоками и как использовать примитивы синхронизации для координации работы потоков.