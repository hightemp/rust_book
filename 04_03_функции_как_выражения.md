# Функции как выражения

В Rust функции являются не только блоками кода, которые можно вызывать, но и выражениями, которые можно использовать в различных контекстах. Это делает язык более гибким и выразительным, позволяя писать более лаконичный и элегантный код.

## Выражения и инструкции в Rust

Прежде чем углубиться в тему функций как выражений, давайте вспомним разницу между выражениями и инструкциями в Rust:

- **Выражение** (expression) - это фрагмент кода, который вычисляется и возвращает значение.
- **Инструкция** (statement) - это действие, которое выполняется, но не возвращает значение.

В Rust большинство конструкций являются выражениями, что делает язык более выразительным. Например:

```rust
let x = 5; // Инструкция (не возвращает значение)
let y = { // Блок кода как выражение
    let a = 3;
    a + 1 // Выражение, возвращает 4
}; // y получает значение 4
```

## Функции как выражения

В Rust функции сами по себе являются выражениями, что означает, что их можно:

1. Присваивать переменным
2. Передавать в качестве аргументов другим функциям
3. Возвращать из функций
4. Использовать в других выражениях

### Присваивание функций переменным

Функции можно присваивать переменным, создавая функциональные указатели:

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    let operation = add; // Присваиваем функцию переменной
    let result = operation(5, 3); // Вызываем функцию через переменную
    println!("Результат: {}", result); // Выведет 8
}
```

Тип функционального указателя можно явно указать:

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    let operation: fn(i32, i32) -> i32 = add;
    let result = operation(5, 3);
    println!("Результат: {}", result);
}
```

### Передача функций в качестве аргументов

Функции можно передавать в качестве аргументов другим функциям:

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

fn apply_operation(a: i32, b: i32, operation: fn(i32, i32) -> i32) -> i32 {
    operation(a, b)
}

fn main() {
    let result1 = apply_operation(5, 3, add);
    let result2 = apply_operation(5, 3, multiply);
    
    println!("Результат сложения: {}", result1); // 8
    println!("Результат умножения: {}", result2); // 15
}
```

Это позволяет создавать более гибкие и переиспользуемые функции высшего порядка.

### Возврат функций из функций

Функции также можно возвращать из других функций:

```rust
fn get_operation(operation_type: &str) -> fn(i32, i32) -> i32 {
    if operation_type == "add" {
        add
    } else {
        multiply
    }
}

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

fn main() {
    let operation = get_operation("add");
    let result = operation(5, 3);
    println!("Результат: {}", result); // 8
    
    let operation = get_operation("multiply");
    let result = operation(5, 3);
    println!("Результат: {}", result); // 15
}
```

## Тело функции как выражение

В Rust тело функции может быть выражением, что позволяет писать более лаконичный код:

```rust
// Традиционный стиль с блоком кода
fn add_verbose(a: i32, b: i32) -> i32 {
    return a + b;
}

// Лаконичный стиль с выражением
fn add_concise(a: i32, b: i32) -> i32 {
    a + b // Обратите внимание на отсутствие точки с запятой и return
}
```

Обе функции эквивалентны, но вторая более лаконична и считается более идиоматичной в Rust.

## Условные выражения в функциях

Условные конструкции в Rust также являются выражениями, что позволяет использовать их для возврата значений из функций:

```rust
fn max(a: i32, b: i32) -> i32 {
    if a > b {
        a
    } else {
        b
    }
}

fn main() {
    let result = max(5, 10);
    println!("Максимальное значение: {}", result); // 10
}
```

## Match выражения в функциях

Выражение `match` также можно использовать для возврата значений из функций:

```rust
fn number_to_string(n: i32) -> &'static str {
    match n {
        1 => "один",
        2 => "два",
        3 => "три",
        _ => "много",
    }
}

fn main() {
    println!("{}", number_to_string(1)); // "один"
    println!("{}", number_to_string(5)); // "много"
}
```

## Замыкания (closures) как выражения

Замыкания (анонимные функции) в Rust также являются выражениями и могут использоваться в различных контекстах:

```rust
fn main() {
    // Определение замыкания
    let add = |a, b| a + b;
    
    // Использование замыкания
    let result = add(5, 3);
    println!("Результат: {}", result); // 8
    
    // Замыкание как выражение в другом выражении
    let result = (|a, b| a * b)(5, 3);
    println!("Результат: {}", result); // 15
    
    // Замыкание с явным указанием типов
    let multiply: fn(i32, i32) -> i32 = |a, b| a * b;
    let result = multiply(5, 3);
    println!("Результат: {}", result); // 15
}
```

### Замыкания с захватом переменных

Одно из ключевых отличий замыканий от обычных функций - это способность захватывать переменные из окружающей области видимости:

```rust
fn main() {
    let factor = 2;
    
    // Замыкание, захватывающее переменную factor
    let multiply_by_factor = |x| x * factor;
    
    let result = multiply_by_factor(5);
    println!("Результат: {}", result); // 10
}
```

### Замыкания как аргументы функций

Замыкания часто используются в качестве аргументов функций, особенно при работе с коллекциями:

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // Использование замыкания с методом map
    let doubled: Vec<i32> = numbers.iter().map(|&x| x * 2).collect();
    println!("Удвоенные числа: {:?}", doubled); // [2, 4, 6, 8, 10]
    
    // Использование замыкания с методом filter
    let even: Vec<i32> = numbers.iter().filter(|&&x| x % 2 == 0).cloned().collect();
    println!("Четные числа: {:?}", even); // [2, 4]
}
```

## Функциональное программирование с использованием функций как выражений

Возможность использовать функции как выражения делает Rust подходящим для функционального стиля программирования:

### Композиция функций

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn multiply_by_two(x: i32) -> i32 {
    x * 2
}

fn main() {
    // Композиция функций
    let result = multiply_by_two(add_one(5));
    println!("Результат: {}", result); // (5 + 1) * 2 = 12
    
    // Альтернативный способ с использованием замыканий
    let add_one_and_multiply = |x| multiply_by_two(add_one(x));
    let result = add_one_and_multiply(5);
    println!("Результат: {}", result); // 12
}
```

### Функции высшего порядка

Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов или возвращают их:

```rust
fn apply_twice<F>(f: F, x: i32) -> i32
where
    F: Fn(i32) -> i32,
{
    f(f(x))
}

fn main() {
    let add_one = |x| x + 1;
    let result = apply_twice(add_one, 5);
    println!("Результат: {}", result); // (5 + 1) + 1 = 7
    
    let multiply_by_two = |x| x * 2;
    let result = apply_twice(multiply_by_two, 5);
    println!("Результат: {}", result); // (5 * 2) * 2 = 20
}
```

## Практические примеры

### Пример 1: Калькулятор с функциями как выражениями

```rust
fn add(a: f64, b: f64) -> f64 {
    a + b
}

fn subtract(a: f64, b: f64) -> f64 {
    a - b
}

fn multiply(a: f64, b: f64) -> f64 {
    a * b
}

fn divide(a: f64, b: f64) -> f64 {
    if b != 0.0 {
        a / b
    } else {
        panic!("Деление на ноль!")
    }
}

fn calculate(a: f64, b: f64, operation: fn(f64, f64) -> f64) -> f64 {
    operation(a, b)
}

fn main() {
    let operations = [
        ("Сложение", add as fn(f64, f64) -> f64),
        ("Вычитание", subtract),
        ("Умножение", multiply),
        ("Деление", divide),
    ];
    
    let a = 10.0;
    let b = 5.0;
    
    for (name, operation) in operations.iter() {
        let result = calculate(a, b, *operation);
        println!("{}: {} {} = {}", name, a, b, result);
    }
}
```

### Пример 2: Обработка списка с функциями как выражениями

```rust
fn process_list<F>(list: &[i32], processor: F) -> Vec<i32>
where
    F: Fn(i32) -> i32,
{
    list.iter().map(|&item| processor(item)).collect()
}

fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    let double = |x| x * 2;
    let square = |x| x * x;
    let add_one = |x| x + 1;
    
    let doubled = process_list(&numbers, double);
    let squared = process_list(&numbers, square);
    let incremented = process_list(&numbers, add_one);
    
    println!("Исходный список: {:?}", numbers);
    println!("Удвоенный список: {:?}", doubled);
    println!("Список квадратов: {:?}", squared);
    println!("Список с добавлением единицы: {:?}", incremented);
}
```

### Пример 3: Создание конвейера обработки данных

```rust
fn main() {
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    // Создаем конвейер обработки данных с использованием функций как выражений
    let result: Vec<i32> = data.iter()
        .filter(|&&x| x % 2 == 0) // Оставляем только четные числа
        .map(|&x| x * x) // Возводим в квадрат
        .filter(|&x| x > 20) // Оставляем только числа больше 20
        .map(|x| x + 1) // Добавляем 1
        .collect();
    
    println!("Исходные данные: {:?}", data);
    println!("Результат обработки: {:?}", result); // [37, 65, 101]
}
```

## Преимущества использования функций как выражений

1. **Лаконичность**: Код становится более компактным и читаемым.
2. **Выразительность**: Можно выразить сложные идеи более ясно и непосредственно.
3. **Композиция**: Функции можно комбинировать для создания более сложных операций.
4. **Переиспользуемость**: Функции можно передавать и использовать в различных контекстах.
5. **Функциональный стиль**: Поддержка функционального программирования делает код более декларативным.

## Ограничения и особенности

1. **Статическая типизация**: В отличие от динамически типизированных языков, в Rust типы функций должны быть известны на этапе компиляции.
2. **Время жизни**: При работе с замыканиями, захватывающими ссылки, необходимо учитывать правила времени жизни.
3. **Трейты для замыканий**: Замыкания в Rust реализуют трейты `Fn`, `FnMut` или `FnOnce`, что влияет на способ их использования.

## Заключение

Функции как выражения - это мощная концепция в Rust, которая позволяет писать более выразительный, лаконичный и гибкий код. Понимание этой концепции открывает новые возможности для структурирования кода и решения задач в функциональном стиле.

В следующем разделе мы рассмотрим модули и области видимости в Rust, что позволит нам организовывать код в более крупные и управляемые структуры.