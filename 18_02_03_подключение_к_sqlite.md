# Подключение к SQLite в Rust

## Введение

SQLite — это легковесная встраиваемая реляционная база данных, которая не требует отдельного серверного процесса и хранит всю базу данных в одном файле. Благодаря своей компактности, надежности и простоте использования, SQLite является одной из самых распространенных баз данных в мире, особенно для мобильных приложений, встраиваемых систем и небольших веб-приложений.

В этой главе мы рассмотрим различные способы подключения к SQLite из Rust-приложений, включая синхронные и асинхронные подходы, использование пулов соединений и ORM-библиотек.

## Основные библиотеки для работы с SQLite в Rust

Для работы с SQLite в Rust существует несколько основных библиотек:

1. **rusqlite** - нативный драйвер для синхронного подключения
2. **sqlx** - асинхронная библиотека с поддержкой SQLite
3. **diesel** - ORM с поддержкой SQLite
4. **r2d2-sqlite** - пул соединений для rusqlite
5. **SeaORM** - асинхронный ORM с поддержкой SQLite

## Особенности SQLite

Прежде чем начать работу с SQLite в Rust, важно понимать некоторые особенности этой базы данных:

1. **Файловая база данных** - вся база данных хранится в одном файле, что упрощает резервное копирование и перенос.
2. **Встраиваемость** - SQLite не требует установки отдельного сервера, библиотека встраивается непосредственно в приложение.
3. **Отсутствие параллельных записей** - SQLite блокирует всю базу данных при записи, что может вызвать проблемы в многопоточных приложениях с интенсивной записью.
4. **Типизация** - SQLite имеет динамическую типизацию, что отличает ее от других SQL баз данных.
5. **Ограничения** - SQLite имеет некоторые ограничения по сравнению с полноценными СУБД, например, ограниченную поддержку ALTER TABLE.

## Синхронное подключение с библиотекой rusqlite

Библиотека `rusqlite` предоставляет синхронный API для работы с SQLite.

### Добавление зависимостей

Добавьте в `Cargo.toml`:

```toml
[dependencies]
rusqlite = "0.28.0"
```

### Базовое подключение

```rust
use rusqlite::{Connection, Result};

fn main() -> Result<()> {
    // Подключаемся к базе данных (файлу)
    // Если файл не существует, он будет создан
    let conn = Connection::open("my_database.db")?;
    
    // Проверяем подключение простым запросом
    let version: String = conn.query_row("SELECT sqlite_version()", [], |row| row.get(0))?;
    
    println!("Подключение к SQLite успешно!");
    println!("Версия SQLite: {}", version);
    
    Ok(())
}
```

### Создание таблицы и вставка данных

```rust
use rusqlite::{Connection, Result};

fn main() -> Result<()> {
    let conn = Connection::open("my_database.db")?;
    
    // Создаем таблицу
    conn.execute(
        "CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY,
            name TEXT NOT NULL,
            email TEXT NOT NULL UNIQUE,
            active INTEGER NOT NULL DEFAULT 1
        )",
        [],
    )?;
    
    // Вставляем данные
    conn.execute(
        "INSERT INTO users (name, email) VALUES (?1, ?2)
         ON CONFLICT(email) DO UPDATE SET name = ?1",
        ["Иван Иванов", "ivan@example.com"],
    )?;
    
    println!("Таблица создана и данные вставлены");
    
    Ok(())
}
```

### Выполнение запросов и получение результатов

```rust
use rusqlite::{Connection, Result};

#[derive(Debug)]
struct User {
    id: i32,
    name: String,
    email: String,
    active: bool,
}

fn main() -> Result<()> {
    let conn = Connection::open("my_database.db")?;
    
    // Выполняем запрос
    let mut stmt = conn.prepare("SELECT id, name, email, active FROM users WHERE active = ?1")?;
    let user_iter = stmt.query_map([1], |row| {
        Ok(User {
            id: row.get(0)?,
            name: row.get(1)?,
            email: row.get(2)?,
            active: row.get::<_, i32>(3)? != 0,
        })
    })?;
    
    // Обрабатываем результаты
    println!("Активные пользователи:");
    for user in user_iter {
        let user = user?;
        println!("#{}: {} ({}) - активен: {}", 
                 user.id, user.name, user.email, user.active);
    }
    
    Ok(())
}
```

### Использование транзакций

```rust
use rusqlite::{Connection, Result};

fn main() -> Result<()> {
    let conn = Connection::open("my_database.db")?;
    
    // Начинаем транзакцию
    let tx = conn.transaction()?;
    
    // Выполняем операции в рамках транзакции
    tx.execute(
        "INSERT INTO users (name, email) VALUES (?1, ?2)",
        ["Петр Петров", "petr@example.com"],
    )?;
    
    tx.execute(
        "UPDATE users SET active = 0 WHERE email = ?1",
        ["ivan@example.com"],
    )?;
    
    // Фиксируем транзакцию
    tx.commit()?;
    
    println!("Транзакция успешно выполнена");
    
    Ok(())
}
```

### Подготовленные выражения

```rust
use rusqlite::{Connection, Result};

fn main() -> Result<()> {
    let conn = Connection::open("my_database.db")?;
    
    // Подготавливаем выражение
    let mut stmt = conn.prepare("INSERT INTO users (name, email) VALUES (?1, ?2)")?;
    
    // Выполняем подготовленное выражение несколько раз
    stmt.execute(["Алексей Алексеев", "alex@example.com"])?;
    stmt.execute(["Мария Иванова", "maria@example.com"])?;
    stmt.execute(["Сергей Сидоров", "sergey@example.com"])?;
    
    println!("Данные успешно вставлены");
    
    Ok(())
}
```

### Пакетная вставка данных

```rust
use rusqlite::{Connection, Result, params_from_iter};

fn main() -> Result<()> {
    let conn = Connection::open("my_database.db")?;
    
    // Подготавливаем данные для пакетной вставки
    let users = vec![
        ("Анна Смирнова", "anna@example.com"),
        ("Дмитрий Козлов", "dmitry@example.com"),
        ("Елена Петрова", "elena@example.com"),
    ];
    
    // Начинаем транзакцию для пакетной вставки
    let tx = conn.transaction()?;
    
    {
        let mut stmt = tx.prepare("INSERT INTO users (name, email) VALUES (?1, ?2)")?;
        
        for user in &users {
            stmt.execute([user.0, user.1])?;
        }
    }
    
    tx.commit()?;
    
    println!("Пакетная вставка успешно выполнена");
    
    Ok(())
} 
```

### Использование базы данных в памяти

SQLite позволяет создавать базы данных, которые существуют только в памяти, что полезно для тестирования или временных данных:

```rust
use rusqlite::{Connection, Result};

fn main() -> Result<()> {
    // Создаем базу данных в памяти
    let conn = Connection::open_in_memory()?;
    
    // Создаем таблицу
    conn.execute(
        "CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)",
        [],
    )?;
    
    // Вставляем данные
    conn.execute(
        "INSERT INTO test (name) VALUES (?1)",
        ["Тестовая запись"],
    )?;
    
    // Проверяем, что данные вставлены
    let name: String = conn.query_row(
        "SELECT name FROM test WHERE id = 1",
        [],
        |row| row.get(0),
    )?;
    
    println!("Запись в памяти: {}", name);
    
    Ok(())
}
```

### Работа с функциями SQLite

SQLite позволяет определять пользовательские функции на Rust:

```rust
use rusqlite::{Connection, Result, functions::FunctionFlags};

fn main() -> Result<()> {
    let conn = Connection::open("my_database.db")?;
    
    // Определяем пользовательскую функцию
    conn.create_scalar_function(
        "reverse",
        1,
        FunctionFlags::SQLITE_UTF8 | FunctionFlags::SQLITE_DETERMINISTIC,
        |ctx| {
            let text = ctx.get::<String>(0)?;
            Ok(text.chars().rev().collect::<String>())
        },
    )?;
    
    // Используем функцию
    let reversed: String = conn.query_row(
        "SELECT reverse(?1)",
        ["Hello, world!"],
        |row| row.get(0),
    )?;
    
    println!("Результат функции reverse: {}", reversed);
    
    Ok(())
}
```

## Пул соединений с r2d2-sqlite

Для эффективной работы с базой данных в многопоточных приложениях рекомендуется использовать пул соединений.

### Добавление зависимостей

```toml
[dependencies]
rusqlite = "0.28.0"
r2d2 = "0.8"
r2d2_sqlite = "0.21.0"
```

### Создание и использование пула

```rust
use rusqlite::{Result as SqliteResult};
use r2d2_sqlite::SqliteConnectionManager;
use r2d2::Pool;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Создаем менеджер соединений
    let manager = SqliteConnectionManager::file("my_database.db");
    
    // Создаем пул с максимум 10 соединениями
    let pool = Pool::builder()
        .max_size(10)
        .build(manager)?;
    
    // Получаем соединение из пула
    let conn = pool.get()?;
    
    // Используем соединение
    let version: String = conn.query_row("SELECT sqlite_version()", [], |row| row.get(0))?;
    
    println!("Подключение через пул успешно!");
    println!("Версия SQLite: {}", version);
    
    // Соединение автоматически возвращается в пул при выходе из области видимости
    
    Ok(())
}
```

### Использование пула в многопоточном приложении

```rust
use rusqlite::{Result as SqliteResult};
use r2d2_sqlite::SqliteConnectionManager;
use r2d2::Pool;
use std::thread;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Создаем пул соединений
    let manager = SqliteConnectionManager::file("my_database.db");
    let pool = Pool::builder()
        .max_size(10)
        .build(manager)?;
    
    // Создаем вектор для хранения дескрипторов потоков
    let mut handles = vec![];
    
    // Запускаем 5 потоков, каждый из которых использует соединение из пула
    for i in 0..5 {
        // Клонируем пул для использования в потоке
        let pool_clone = pool.clone();
        
        // Создаем новый поток
        let handle = thread::spawn(move || {
            // Получаем соединение из пула
            let conn = pool_clone.get().unwrap();
            
            // Выполняем запрос
            let result: i32 = conn.query_row(
                "SELECT ?1",
                [i],
                |row| row.get(0),
            ).unwrap();
            
            println!("Поток {} выполнил запрос, результат: {}", i, result);
            
            result
        });
        
        handles.push(handle);
    }
    
    // Ожидаем завершения всех потоков
    for handle in handles {
        let result = handle.join().unwrap();
        println!("Поток вернул: {}", result);
    }
    
    println!("Все потоки завершены");
    
    Ok(())
}
```
