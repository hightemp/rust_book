# Операторы и выражения в Rust

## Введение

Операторы и выражения являются фундаментальными элементами любого языка программирования. В Rust они имеют некоторые особенности, которые отличают его от других языков. Одна из ключевых особенностей Rust заключается в том, что почти всё в языке является выражением, которое возвращает значение.

В этой главе мы рассмотрим:
- Различные типы операторов в Rust
- Концепцию выражений и их использование
- Приоритет операторов
- Примеры использования операторов и выражений
- Лучшие практики

## Операторы

Операторы в Rust используются для выполнения различных операций над данными. Они могут быть классифицированы по типу операции, которую они выполняют.

### Арифметические операторы

Арифметические операторы используются для выполнения математических операций:

| Оператор | Описание | Пример |
|----------|----------|--------|
| `+` | Сложение | `5 + 3` равно `8` |
| `-` | Вычитание | `5 - 3` равно `2` |
| `*` | Умножение | `5 * 3` равно `15` |
| `/` | Деление | `5 / 3` равно `1` (для целых чисел) или `1.6666...` (для чисел с плавающей точкой) |
| `%` | Остаток от деления | `5 % 3` равно `2` |

Пример использования арифметических операторов:

```rust
fn main() {
    // Целочисленная арифметика
    let sum = 5 + 10;
    let difference = 95.5 - 4.3;
    let product = 4 * 30;
    let quotient = 56.7 / 32.2;
    let remainder = 43 % 5;
    
    println!("Сумма: {}", sum);
    println!("Разность: {}", difference);
    println!("Произведение: {}", product);
    println!("Частное: {}", quotient);
    println!("Остаток: {}", remainder);
}
```

#### Переполнение

В Rust арифметические операции над целыми числами могут привести к переполнению. По умолчанию, в режиме отладки (debug mode) Rust проверяет переполнение и вызывает панику, если оно происходит. В режиме выпуска (release mode) переполнение приводит к "обёртыванию" (wrapping), то есть значение "заворачивается" и начинается с начала диапазона.

Rust предоставляет методы для явного управления переполнением:

```rust
fn main() {
    let a: u8 = 255;
    
    // Эти операции вызовут панику в режиме отладки
    // let b = a + 1; // Переполнение
    
    // Явное управление переполнением
    let wrapped = a.wrapping_add(1); // Обёртывание: 0
    let saturated = a.saturating_add(1); // Насыщение: 255
    let overflowed = a.overflowing_add(1); // Кортеж (значение, был_ли_переполнение): (0, true)
    let checked = a.checked_add(1); // Option: None (если было переполнение)
    
    println!("wrapped: {}", wrapped);
    println!("saturated: {}", saturated);
    println!("overflowed: {:?}", overflowed);
    println!("checked: {:?}", checked);
}
```

### Операторы сравнения

Операторы сравнения используются для сравнения значений и возвращают логическое значение (`bool`):

| Оператор | Описание | Пример |
|----------|----------|--------|
| `==` | Равно | `5 == 5` равно `true` |
| `!=` | Не равно | `5 != 5` равно `false` |
| `>` | Больше | `5 > 3` равно `true` |
| `<` | Меньше | `5 < 3` равно `false` |
| `>=` | Больше или равно | `5 >= 5` равно `true` |
| `<=` | Меньше или равно | `5 <= 3` равно `false` |

Пример использования операторов сравнения:

```rust
fn main() {
    let x = 5;
    let y = 10;
    
    println!("x равно y: {}", x == y);
    println!("x не равно y: {}", x != y);
    println!("x больше y: {}", x > y);
    println!("x меньше y: {}", x < y);
    println!("x больше или равно y: {}", x >= y);
    println!("x меньше или равно y: {}", x <= y);
}
```

### Логические операторы

Логические операторы используются для комбинирования логических значений:

| Оператор | Описание | Пример |
|----------|----------|--------|
| `&&` | Логическое И | `true && false` равно `false` |
| `\|\|` | Логическое ИЛИ | `true \|\| false` равно `true` |
| `!` | Логическое НЕ | `!true` равно `false` |

Пример использования логических операторов:

```rust
fn main() {
    let x = 5;
    let y = 10;
    
    // Логическое И: оба условия должны быть истинными
    let both_conditions = x < 10 && y > 5;
    println!("x < 10 И y > 5: {}", both_conditions);
    
    // Логическое ИЛИ: хотя бы одно условие должно быть истинным
    let either_condition = x < 10 || y < 5;
    println!("x < 10 ИЛИ y < 5: {}", either_condition);
    
    // Логическое НЕ: инвертирует значение
    let not_condition = !(x == 5);
    println!("НЕ (x == 5): {}", not_condition);
}
```

Логические операторы в Rust используют "короткое замыкание" (short-circuit evaluation). Это означает, что если результат операции может быть определен после вычисления первого операнда, второй операнд не вычисляется:

```rust
fn main() {
    let x = 5;
    
    // Второе условие не вычисляется, так как первое уже false
    let result = x > 10 && some_function();
    
    // Второе условие не вычисляется, так как первое уже true
    let result = x < 10 || some_function();
}

fn some_function() -> bool {
    println!("Функция вызвана");
    true
}
```

### Побитовые операторы

Побитовые операторы используются для манипуляции отдельными битами в числах:

| Оператор | Описание | Пример |
|----------|----------|--------|
| `&` | Побитовое И | `5 & 3` равно `1` |
| `\|` | Побитовое ИЛИ | `5 \| 3` равно `7` |
| `^` | Побитовое исключающее ИЛИ (XOR) | `5 ^ 3` равно `6` |
| `!` | Побитовое НЕ | `!5` равно `-6` (для i32) |
| `<<` | Сдвиг влево | `5 << 1` равно `10` |
| `>>` | Сдвиг вправо | `5 >> 1` равно `2` |

Пример использования побитовых операторов:

```rust
fn main() {
    let a = 0b1010; // 10 в двоичной системе
    let b = 0b1100; // 12 в двоичной системе
    
    println!("a = {} (двоичное: {:b})", a, a);
    println!("b = {} (двоичное: {:b})", b, b);
    
    // Побитовое И
    let and = a & b; // 0b1000 (8)
    println!("a & b = {} (двоичное: {:b})", and, and);
    
    // Побитовое ИЛИ
    let or = a | b; // 0b1110 (14)
    println!("a | b = {} (двоичное: {:b})", or, or);
    
    // Побитовое исключающее ИЛИ
    let xor = a ^ b; // 0b0110 (6)
    println!("a ^ b = {} (двоичное: {:b})", xor, xor);
    
    // Побитовое НЕ (инвертирует все биты)
    let not = !a; // Зависит от типа a
    println!("!a = {} (двоичное: {:b})", not, not);
    
    // Сдвиг влево (умножение на 2^n)
    let left_shift = a << 1; // 0b10100 (20)
    println!("a << 1 = {} (двоичное: {:b})", left_shift, left_shift);
    
    // Сдвиг вправо (деление на 2^n)
    let right_shift = a >> 1; // 0b0101 (5)
    println!("a >> 1 = {} (двоичное: {:b})", right_shift, right_shift);
}
```

Побитовые операторы часто используются для работы с флагами, маскирования битов и оптимизации некоторых операций.

### Операторы присваивания

Операторы присваивания используются для присвоения значений переменным:

| Оператор | Описание | Пример |
|----------|----------|--------|
| `=` | Простое присваивание | `x = 5` |
| `+=` | Присваивание с сложением | `x += 3` эквивалентно `x = x + 3` |
| `-=` | Присваивание с вычитанием | `x -= 3` эквивалентно `x = x - 3` |
| `*=` | Присваивание с умножением | `x *= 3` эквивалентно `x = x * 3` |
| `/=` | Присваивание с делением | `x /= 3` эквивалентно `x = x / 3` |
| `%=` | Присваивание с остатком от деления | `x %= 3` эквивалентно `x = x % 3` |
| `&=` | Присваивание с побитовым И | `x &= 3` эквивалентно `x = x & 3` |
| `\|=` | Присваивание с побитовым ИЛИ | `x \|= 3` эквивалентно `x = x \| 3` |
| `^=` | Присваивание с побитовым исключающим ИЛИ | `x ^= 3` эквивалентно `x = x ^ 3` |
| `<<=` | Присваивание с сдвигом влево | `x <<= 3` эквивалентно `x = x << 3` |
| `>>=` | Присваивание с сдвигом вправо | `x >>= 3` эквивалентно `x = x >> 3` |

Пример использования операторов присваивания:

```rust
fn main() {
    let mut x = 5;
    println!("Начальное значение x: {}", x);
    
    x += 3;
    println!("После x += 3: {}", x);
    
    x -= 2;
    println!("После x -= 2: {}", x);
    
    x *= 2;
    println!("После x *= 2: {}", x);
    
    x /= 3;
    println!("После x /= 3: {}", x);
    
    x %= 2;
    println!("После x %= 2: {}", x);
    
    x |= 3;
    println!("После x |= 3: {}", x);
    
    x &= 2;
    println!("После x &= 2: {}", x);
    
    x ^= 1;
    println!("После x ^= 1: {}", x);
    
    x <<= 1;
    println!("После x <<= 1: {}", x);
    
    x >>= 1;
    println!("После x >>= 1: {}", x);
}
```

## Выражения в Rust

Одна из ключевых особенностей Rust заключается в том, что почти всё в языке является выражением, которое возвращает значение. Это делает код более компактным и выразительным.

### Блоки как выражения

В Rust блок кода (заключенный в фигурные скобки) является выражением, которое возвращает значение последнего выражения в блоке (если оно не заканчивается точкой с запятой):

```rust
fn main() {
    let x = 5;
    
    let y = {
        let z = x + 1;
        z * 2 // Обратите внимание на отсутствие точки с запятой
    };
    
    println!("y = {}", y); // Выведет "y = 12"
}
```

В этом примере блок `{ let z = x + 1; z * 2 }` является выражением, которое возвращает значение `z * 2`, то есть `12`.

Если последнее выражение в блоке заканчивается точкой с запятой, блок возвращает единичное значение `()` (unit value):

```rust
fn main() {
    let x = 5;
    
    let y = {
        let z = x + 1;
        z * 2; // Обратите внимание на точку с запятой
    };
    
    println!("y = {:?}", y); // Выведет "y = ()"
}
```

### Условные выражения

В Rust условные конструкции `if`/`else` также являются выражениями:

```rust
fn main() {
    let condition = true;
    
    let number = if condition {
        5
    } else {
        6
    };
    
    println!("number = {}", number); // Выведет "number = 5"
}
```

Важно отметить, что все ветви `if`/`else` должны возвращать значения одного типа:

```rust
fn main() {
    let condition = true;
    
    // Ошибка компиляции: несовместимые типы
    // let number = if condition {
    //     5
    // } else {
    //     "six"
    // };
}
```

### Выражения match

Выражение `match` в Rust также возвращает значение:

```rust
fn main() {
    let number = 3;
    
    let result = match number {
        1 => "один",
        2 => "два",
        3 => "три",
        _ => "много",
    };
    
    println!("result = {}", result); // Выведет "result = три"
}
```

Выражение `match` должно быть исчерпывающим, то есть должны быть рассмотрены все возможные значения. Часто для этого используется шаблон `_` (подчеркивание), который соответствует любому значению.

### Циклы как выражения

Циклы `loop`, `while` и `for` также могут быть использованы как выражения. Цикл `loop` может возвращать значение с помощью ключевого слова `break`:

```rust
fn main() {
    let mut counter = 0;
    
    let result = loop {
        counter += 1;
        
        if counter == 10 {
            break counter * 2;
        }
    };
    
    println!("result = {}", result); // Выведет "result = 20"
}
```

Циклы `while` и `for` всегда возвращают единичное значение `()`.

## Приоритет операторов

Операторы в Rust имеют определенный приоритет, который определяет порядок их выполнения в выражениях. Вот таблица приоритета операторов в Rust (от высшего к низшему):

| Приоритет | Оператор | Ассоциативность |
|-----------|----------|-----------------|
| 1 | `!` `-` (унарный) | Справа налево |
| 2 | `*` `/` `%` | Слева направо |
| 3 | `+` `-` (бинарный) | Слева направо |
| 4 | `<<` `>>` | Слева направо |
| 5 | `&` | Слева направо |
| 6 | `^` | Слева направо |
| 7 | `\|` | Слева направо |
| 8 | `==` `!=` `<` `>` `<=` `>=` | Слева направо |
| 9 | `&&` | Слева направо |
| 10 | `\|\|` | Слева направо |
| 11 | `=` `+=` `-=` и т.д. | Справа налево |

Если вы не уверены в приоритете операторов, всегда лучше использовать скобки для явного указания порядка выполнения операций:

```rust
fn main() {
    let a = 5;
    let b = 3;
    let c = 2;
    
    // Без скобок: сначала выполняется умножение, затем сложение
    let result1 = a + b * c; // 5 + (3 * 2) = 11
    
    // Со скобками: сначала выполняется сложение, затем умножение
    let result2 = (a + b) * c; // (5 + 3) * 2 = 16
    
    println!("result1 = {}", result1);
    println!("result2 = {}", result2);
}
```

## Примеры использования операторов и выражений

### Пример 1: Вычисление абсолютного значения

```rust
fn main() {
    let number = -42;
    
    // Используем условное выражение для вычисления абсолютного значения
    let absolute = if number >= 0 {
        number
    } else {
        -number
    };
    
    println!("Абсолютное значение {} равно {}", number, absolute);
}
```

### Пример 2: Проверка четности числа

```rust
fn main() {
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    for &number in &numbers {
        // Используем оператор остатка от деления для проверки четности
        let is_even = number % 2 == 0;
        
        // Используем условное выражение для вывода результата
        let description = if is_even {
            "четное"
        } else {
            "нечетное"
        };
        
        println!("{} - {}", number, description);
    }
}
```

### Пример 3: Вычисление факториала

```rust
fn main() {
    let n = 5;
    
    // Используем цикл как выражение для вычисления факториала
    let factorial = {
        let mut result = 1;
        let mut i = 1;
        
        while i <= n {
            result *= i;
            i += 1;
        }
        
        result
    };
    
    println!("{}! = {}", n, factorial);
}
```

### Пример 4: Работа с битами

```rust
fn main() {
    let flags = 0b1010; // Двоичное представление числа 10
    
    // Проверяем, установлен ли второй бит (считая с 0)
    let is_second_bit_set = (flags & (1 << 1)) != 0;
    println!("Второй бит установлен: {}", is_second_bit_set);
    
    // Устанавливаем третий бит
    let new_flags = flags | (1 << 2);
    println!("Новые флаги: {:b}", new_flags);
    
    // Сбрасываем первый бит
    let cleared_flags = new_flags & !(1 << 0);
    println!("Флаги после сброса первого бита: {:b}", cleared_flags);
    
    // Инвертируем четвертый бит
    let toggled_flags = cleared_flags ^ (1 << 3);
    println!("Флаги после инвертирования четвертого бита: {:b}", toggled_flags);
}
```

## Лучшие практики

1. **Используйте скобки для ясности**: Даже если вы знаете приоритет операторов, использование скобок может сделать код более читаемым и понятным.

2. **Избегайте сложных выражений**: Разбивайте сложные выражения на более простые части, используя промежуточные переменные.

3. **Используйте выражения вместо операторов**: Rust позволяет использовать выражения в местах, где в других языках требуются операторы. Это делает код более компактным и выразительным.

4. **Будьте осторожны с побочными эффектами**: Помните, что операторы и выражения могут иметь побочные эффекты, такие как изменение переменных или вызов функций.

5. **Используйте методы для сложных операций**: Для сложных операций, таких как работа с переполнением, используйте соответствующие методы (`wrapping_add`, `saturating_add` и т.д.) вместо обычных операторов.

6. **Помните о типах**: Операторы в Rust работают только с совместимыми типами. Убедитесь, что типы операндов совместимы или выполните явное преобразование типов.

## Упражнения

1. **Вычисление среднего значения**:
   Напишите программу, которая вычисляет среднее значение трех чисел, используя арифметические операторы и выражения.

2. **Проверка диапазона**:
   Создайте функцию, которая проверяет, находится ли число в заданном диапазоне (включительно), используя логические операторы.

3. **Работа с битами**:
   Напишите программу, которая принимает число и выполняет следующие операции:
   - Проверяет, является ли число степенью двойки
   - Подсчитывает количество установленных битов
   - Находит позицию самого правого установленного бита

4. **Условные выражения**:
   Создайте функцию, которая возвращает максимальное из трех чисел, используя только условные выражения (без использования стандартных функций `max`).

## Заключение

Операторы и выражения в Rust предоставляют мощные инструменты для манипуляции данными и управления потоком выполнения программы. Понимание того, как они работают и взаимодействуют друг с другом, является важным шагом в освоении языка.

Особенность Rust, заключающаяся в том, что почти всё является выражением, делает код более компактным и выразительным, но также требует некоторого привыкания для разработчиков, пришедших из других языков.

В следующей главе мы рассмотрим практическое применение операторов и выражений в более сложных программах, а также изучим управление потоком выполнения с помощью условных выражений и циклов.