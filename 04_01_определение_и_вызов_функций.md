# Определение и вызов функций

Функции являются основным строительным блоком кода в Rust, как и во многих других языках программирования. Они позволяют структурировать код, избегать повторений и делать программы более понятными и поддерживаемыми.

## Определение функций

В Rust функции определяются с помощью ключевого слова `fn`, за которым следует имя функции, список параметров в круглых скобках и тело функции в фигурных скобках.

```rust
fn имя_функции(параметр1: тип1, параметр2: тип2) -> тип_возвращаемого_значения {
    // Тело функции
}
```

Пример простой функции, которая ничего не принимает и ничего не возвращает:

```rust
fn say_hello() {
    println!("Привет, мир!");
}
```

### Соглашения по именованию

В Rust принято использовать "змеиный_регистр" (snake_case) для имен функций. Это означает, что все буквы в имени функции должны быть строчными, а слова разделяются символом подчеркивания.

```rust
fn calculate_total_price() {
    // Тело функции
}
```

## Вызов функций

Чтобы вызвать функцию, нужно указать ее имя, за которым следуют круглые скобки с аргументами (если они есть).

```rust
fn main() {
    say_hello(); // Вызов функции say_hello
}
```

## Параметры функций

Функции могут принимать параметры, которые указываются в круглых скобках после имени функции. Для каждого параметра необходимо указать его имя и тип.

```rust
fn greet(name: &str) {
    println!("Привет, {}!", name);
}

fn main() {
    greet("Анна"); // Вызов функции greet с аргументом "Анна"
}
```

Функция может принимать несколько параметров, разделенных запятыми:

```rust
fn add(a: i32, b: i32) {
    println!("Сумма {} и {} равна {}", a, b, a + b);
}

fn main() {
    add(5, 7); // Вызов функции add с аргументами 5 и 7
}
```

## Возвращаемые значения

Функции в Rust могут возвращать значения. Тип возвращаемого значения указывается после стрелки `->` в сигнатуре функции.

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b // Обратите внимание: нет точки с запятой!
}

fn main() {
    let sum = add(5, 7); // sum получит значение 12
    println!("Сумма равна {}", sum);
}
```

В Rust последнее выражение в функции (без точки с запятой) является возвращаемым значением. Это одна из особенностей языка, которая делает код более лаконичным.

Также можно явно указать возвращаемое значение с помощью ключевого слова `return`:

```rust
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
```

Это особенно полезно, когда нужно досрочно вернуть значение из функции:

```rust
fn absolute_value(x: i32) -> i32 {
    if x >= 0 {
        return x;
    }
    -x
}
```

## Функции без возвращаемого значения

Если функция не возвращает значение, можно опустить тип возвращаемого значения:

```rust
fn say_hello() {
    println!("Привет!");
}
```

Технически такая функция возвращает специальный тип `()`, который называется "единичный тип" (unit type) и представляет собой пустое значение или отсутствие значения.

## Функции как объекты первого класса

В Rust функции являются "объектами первого класса", что означает, что их можно присваивать переменным, передавать в качестве аргументов другим функциям и возвращать из функций.

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    let operation = add; // Присваивание функции переменной
    let result = operation(5, 7); // Вызов функции через переменную
    println!("Результат: {}", result);
}
```

## Вложенные функции

В Rust можно определять функции внутри других функций. Такие вложенные функции видны только внутри родительской функции.

```rust
fn main() {
    fn nested_function() {
        println!("Это вложенная функция!");
    }

    nested_function(); // Вызов вложенной функции
}
```

## Рекурсивные функции

Функции в Rust могут вызывать сами себя, что называется рекурсией.

```rust
fn factorial(n: u64) -> u64 {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

fn main() {
    let result = factorial(5); // 5! = 5 * 4 * 3 * 2 * 1 = 120
    println!("Факториал 5 равен {}", result);
}
```

## Практические примеры

### Пример 1: Функция для вычисления площади прямоугольника

```rust
fn calculate_rectangle_area(width: f64, height: f64) -> f64 {
    width * height
}

fn main() {
    let width = 5.0;
    let height = 10.0;
    let area = calculate_rectangle_area(width, height);
    println!("Площадь прямоугольника с шириной {} и высотой {} равна {}", width, height, area);
}
```

### Пример 2: Функция для проверки, является ли число простым

```rust
fn is_prime(n: u32) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    
    true
}

fn main() {
    for i in 1..20 {
        if is_prime(i) {
            println!("{} - простое число", i);
        } else {
            println!("{} - не простое число", i);
        }
    }
}
```

### Пример 3: Функция с несколькими параметрами и условной логикой

```rust
fn grade_student(name: &str, score: u32) -> &'static str {
    let grade = if score >= 90 {
        "A"
    } else if score >= 80 {
        "B"
    } else if score >= 70 {
        "C"
    } else if score >= 60 {
        "D"
    } else {
        "F"
    };
    
    println!("Студент {} получил оценку {}", name, grade);
    grade
}

fn main() {
    let students = [("Алексей", 85), ("Мария", 92), ("Иван", 65), ("Елена", 78)];
    
    for (name, score) in students.iter() {
        grade_student(name, *score);
    }
}
```

## Заключение

Функции в Rust являются мощным инструментом для структурирования кода и повышения его читаемости. Они позволяют разбивать сложные задачи на более простые подзадачи, избегать дублирования кода и делать программы более модульными и поддерживаемыми.

В следующем разделе мы рассмотрим более подробно параметры и возвращаемые значения функций, а также познакомимся с функциями как выражениями в Rust.