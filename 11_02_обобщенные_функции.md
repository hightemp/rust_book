# Обобщенные функции в Rust

Обобщенные функции (generic functions) - это функции, которые могут работать с различными типами данных. Они являются одним из ключевых инструментов обобщенного программирования в Rust, позволяя писать гибкий и повторно используемый код.

## Основы обобщенных функций

Обобщенная функция объявляется с использованием параметров типа в угловых скобках `<>` после имени функции:

```rust
fn some_function<T>(param: T) {
    // Тело функции
}
```

Здесь `T` - это параметр типа, который может быть заменен любым конкретным типом при вызове функции.

## Пример обобщенной функции

Рассмотрим простой пример обобщенной функции, которая возвращает переданное ей значение:

```rust
fn identity<T>(x: T) -> T {
    x
}

fn main() {
    let integer = identity(5);       // T = i32
    let float = identity(5.0);       // T = f64
    let string = identity("hello");  // T = &str
}
```

В этом примере функция `identity` принимает значение любого типа и возвращает его. Тип `T` выводится компилятором на основе типа переданного аргумента.

## Обобщенные функции с несколькими параметрами типа

Функция может иметь несколько параметров типа:

```rust
fn pair<T, U>(first: T, second: U) -> (T, U) {
    (first, second)
}

fn main() {
    let pair_int_str = pair(1, "hello");  // (T, U) = (i32, &str)
    let pair_bool_char = pair(true, 'a'); // (T, U) = (bool, char)
}
```

В этом примере функция `pair` принимает два значения разных типов и возвращает их в виде кортежа.

## Обобщенные функции с ограничениями типов

Часто нам нужно, чтобы параметры типа обладали определенными свойствами. Например, если мы хотим сравнивать значения, типы должны поддерживать операцию сравнения. Для этого используются ограничения типов (trait bounds):

```rust
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```

Здесь `T: PartialOrd` означает, что тип `T` должен реализовывать трейт `PartialOrd`, который обеспечивает возможность сравнения значений.

## Множественные ограничения типов

Мы можем указать несколько ограничений для параметра типа, используя синтаксис `+`:

```rust
fn print_and_return<T: std::fmt::Display + Clone>(value: T) -> T {
    println!("Value: {}", value);
    value.clone()
}
```

В этом примере тип `T` должен реализовывать трейты `Display` (для форматированного вывода) и `Clone` (для клонирования).

## Альтернативный синтаксис для ограничений типов

Для функций с множественными ограничениями типов можно использовать предложение `where` для улучшения читаемости:

```rust
fn some_function<T, U>(t: T, u: U) -> i32
    where T: std::fmt::Display + Clone,
          U: Clone + std::fmt::Debug
{
    // Тело функции
}
```

Этот синтаксис особенно полезен, когда у нас много параметров типа или сложные ограничения.

## Обобщенные функции с параметрами по умолчанию

В Rust нет прямой поддержки параметров типа по умолчанию, как в некоторых других языках. Однако мы можем достичь похожего эффекта, используя трейты с ассоциированными типами и реализации по умолчанию.

## Обобщенные функции и монотипизация

Как упоминалось ранее, Rust использует процесс монотипизации (monomorphization) для обобщенных функций. Это означает, что компилятор генерирует отдельные версии функции для каждого конкретного типа, с которым она используется.

Например, если мы используем функцию `identity` с типами `i32`, `f64` и `&str`, компилятор сгенерирует три разные функции:

```rust
fn identity_i32(x: i32) -> i32 {
    x
}

fn identity_f64(x: f64) -> f64 {
    x
}

fn identity_str(x: &str) -> &str {
    x
}
```

Это обеспечивает высокую производительность обобщенного кода, так как во время выполнения нет никаких накладных расходов на обработку типов.

## Обобщенные функции и статическая диспетчеризация

Благодаря монотипизации, вызовы обобщенных функций в Rust используют статическую диспетчеризацию. Это означает, что конкретная версия функции выбирается во время компиляции, а не во время выполнения.

Это отличается от динамической диспетчеризации, которая используется, например, при вызове методов через трейт-объекты. Статическая диспетчеризация более эффективна, так как не требует поиска нужного метода во время выполнения.

## Обобщенные функции и инлайнинг

Компилятор Rust часто может инлайнить (встраивать) вызовы обобщенных функций, особенно если они небольшие. Это может привести к дополнительной оптимизации кода.

## Обобщенные функции в стандартной библиотеке

Стандартная библиотека Rust широко использует обобщенные функции. Например, функция `std::mem::swap` позволяет обменять значения двух переменных любого типа:

```rust
fn main() {
    let mut x = 5;
    let mut y = 10;
    std::mem::swap(&mut x, &mut y);
    assert_eq!(x, 10);
    assert_eq!(y, 5);
    
    let mut s1 = String::from("hello");
    let mut s2 = String::from("world");
    std::mem::swap(&mut s1, &mut s2);
    assert_eq!(s1, "world");
    assert_eq!(s2, "hello");
}
```

## Заключение

Обобщенные функции - это мощный инструмент в Rust, который позволяет писать гибкий, повторно используемый код без потери производительности. Они являются основой для многих абстракций в стандартной библиотеке и экосистеме Rust.

В следующем разделе мы рассмотрим, как использовать параметры типа для создания обобщенных структур и перечислений.