# Выражение match в Rust

## Введение

Выражение `match` - одна из наиболее мощных и выразительных конструкций в Rust, реализующая механизм сопоставления с образцом (pattern matching). В отличие от простых условных выражений `if`/`else`, `match` позволяет проверять значение на соответствие различным шаблонам и выполнять код в зависимости от результата сопоставления.

В этой главе мы подробно рассмотрим выражение `match` в Rust, его синтаксис, особенности реализации, продвинутые случаи использования и оптимизации компилятора.

## Базовый синтаксис и особенности

### Базовый синтаксис

```rust
match выражение {
    шаблон1 => выражение1,
    шаблон2 => выражение2,
    шаблон3 => {
        // Блок кода
        выражение3
    },
    // Дополнительные шаблоны
    _ => выражение_по_умолчанию,
}
```

Пример:

```rust
let number = 13;

match number {
    // Сопоставление с конкретным значением
    0 => println!("Ноль"),
    // Сопоставление с несколькими значениями
    1 | 2 => println!("Один или два"),
    // Сопоставление с диапазоном
    3..=9 => println!("От трех до девяти"),
    // Связывание переменной
    n if n % 2 == 0 => println!("Четное число: {}", n),
    // Шаблон по умолчанию
    _ => println!("Нечетное число больше 9: {}", number),
}
```

### Особенности выражения match

1. **Исчерпывающая проверка**: компилятор Rust требует, чтобы выражение `match` обрабатывало все возможные значения проверяемого выражения. Если какие-то случаи не обработаны, код не скомпилируется.

```rust
// Ошибка компиляции: неисчерпывающие шаблоны
let x = 5;
match x {
    1 => println!("Один"),
    2 => println!("Два"),
    // Отсутствует обработка других значений
}
```

Для обработки всех остальных случаев можно использовать шаблон `_` (подчеркивание):

```rust
let x = 5;
match x {
    1 => println!("Один"),
    2 => println!("Два"),
    _ => println!("Другое число"),
}
```

2. **Match как выражение**: `match` в Rust является выражением, а не оператором, и может возвращать значение.

```rust
let number = 13;
let description = match number {
    0 => "ноль",
    1 | 2 => "один или два",
    3..=9 => "от трех до девяти",
    _ if number % 2 == 0 => "четное число больше 9",
    _ => "нечетное число больше 9",
};

println!("Число {} - это {}", number, description);
```

3. **Требование к типам возвращаемых значений**: все ветви `match` должны возвращать значения одного и того же типа.

## Сопоставление с образцами (Pattern Matching)

Сопоставление с образцами - это процесс проверки значения на соответствие определенной структуре или шаблону. Rust поддерживает различные типы образцов в выражении `match`.

### Литеральные значения

Самый простой тип образца - литеральное значение:

```rust
let x = 1;

match x {
    1 => println!("Один"),
    2 => println!("Два"),
    _ => println!("Другое число"),
}
```

### Множественные значения и диапазоны

Оператор `|` позволяет указать несколько альтернативных образцов:

```rust
let x = 1;

match x {
    1 | 2 | 3 => println!("от 1 до 3"),
    4 | 5 => println!("4 или 5"),
    _ => println!("другое число"),
}
```

Для числовых типов и символов можно использовать диапазоны:

```rust
let x = 5;

match x {
    1..=5 => println!("от 1 до 5 включительно"),
    6..=10 => println!("от 6 до 10 включительно"),
    _ => println!("другое число"),
}
```

## Деструктуризация в match

Одна из мощных возможностей `match` - деструктуризация сложных типов данных.

### Деструктуризация кортежей

```rust
let pair = (0, -2);

match pair {
    (0, y) => println!("Первый элемент 0, второй: {}", y),
    (x, 0) => println!("Первый элемент {}, второй: 0", x),
    _ => println!("Оба элемента не равны 0"),
}
```

### Деструктуризация структур

```rust
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 0, y: 7 };

match point {
    Point { x: 0, y } => println!("На оси Y: {}", y),
    Point { x, y: 0 } => println!("На оси X: {}", x),
    Point { x, y } => println!("В другом месте: ({}, {})", x, y),
}
```

### Деструктуризация перечислений

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

let msg = Message::ChangeColor(0, 160, 255);

match msg {
    Message::Quit => println!("Выход"),
    Message::Move { x, y } => println!("Перемещение на x={}, y={}", x, y),
    Message::Write(text) => println!("Текст: {}", text),
    Message::ChangeColor(r, g, b) => println!("Изменение цвета на ({}, {}, {})", r, g, b),
}
```

## Охранные выражения (Guards)

Охранные выражения позволяют добавлять дополнительные условия к образцам:

```rust
let num = 4;

match num {
    n if n < 0 => println!("Отрицательное число"),
    n if n > 0 && n % 2 == 0 => println!("Положительное четное число"),
    n if n > 0 => println!("Положительное нечетное число"),
    _ => println!("Ноль"),
}
```

## Связывание переменных в образцах

### Оператор @

Оператор `@` позволяет связать переменную с значением, соответствующим образцу:

```rust
let num = 5;

match num {
    n @ 1..=5 => println!("Число от 1 до 5: {}", n),
    n @ 6..=10 => println!("Число от 6 до 10: {}", n),
    _ => println!("Другое число"),
}
```

### Игнорирование значений

Символ `_` используется для игнорирования значений в образцах:

```rust
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) => {
        println!("Некоторые числа: {}, {}, {}", first, third, fifth)
    }
}
```

Для игнорирования оставшейся части структуры или кортежа можно использовать `..`:

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } => println!("x равен {}", x),
}
```

## Особенности реализации в Rust

### Исчерпывающая проверка

Одна из ключевых особенностей `match` в Rust - требование исчерпывающей проверки всех возможных значений. Компилятор статически проверяет, что все возможные варианты обрабатываются.

### Оптимизация компилятора

Компилятор Rust оптимизирует выражения `match` различными способами:

1. **Таблицы переходов**: для числовых типов и перечислений с числовыми значениями компилятор может генерировать таблицы переходов вместо последовательных сравнений

2. **Бинарный поиск**: для больших диапазонов значений компилятор может использовать алгоритм бинарного поиска

3. **Устранение мертвого кода**: компилятор может удалять ветви, которые никогда не будут выполнены

## Продвинутые случаи использования

### Сопоставление с Option и Result

Выражение `match` часто используется для обработки типов `Option` и `Result`:

```rust
fn process_option(opt: Option<i32>) -> i32 {
    match opt {
        Some(value) => value * 2,
        None => 0,
    }
}

fn process_result(res: Result<i32, String>) -> i32 {
    match res {
        Ok(value) => value * 2,
        Err(error) => {
            eprintln!("Ошибка: {}", error);
            0
        }
    }
}
```

### Условные шаблоны с if let

Для случаев, когда нужно обработать только один вариант, можно использовать `if let` вместо полного `match`:

```rust
let some_value = Some(5);

// Использование match
match some_value {
    Some(value) => println!("Значение: {}", value),
    None => (), // Пустое выражение для None
}

// Эквивалентный код с if let
if let Some(value) = some_value {
    println!("Значение: {}", value);
}
```

## Примеры реальных сценариев использования

### Обработка состояний

Выражение `match` часто используется для обработки различных состояний в программе:

```rust
enum State {
    Start,
    Running { progress: f64 },
    Paused { progress: f64 },
    Finished { result: String },
    Error { message: String },
}

fn process_state(state: State) {
    match state {
        State::Start => {
            println!("Начало выполнения");
            // Инициализация ресурсов
        }
        State::Running { progress } => {
            println!("Выполнение: {}%", progress * 100.0);
            // Обновление прогресса
        }
        State::Paused { progress } => {
            println!("Приостановлено: {}%", progress * 100.0);
            // Сохранение состояния
        }
        State::Finished { result } => {
            println!("Завершено с результатом: {}", result);
            // Освобождение ресурсов
        }
        State::Error { message } => {
            eprintln!("Ошибка: {}", message);
            // Обработка ошибки
        }
    }
}
```

### Обработка команд и событий

Выражение `match` часто используется для обработки команд в интерфейсах командной строки или событий в графических интерфейсах:

```rust
enum Command {
    Get { key: String },
    Set { key: String, value: String },
    Delete { key: String },
    List { prefix: Option<String> },
    Quit,
}

fn process_command(cmd: Command, database: &mut Database) -> Result<String, Error> {
    match cmd {
        Command::Get { key } => {
            match database.get(&key) {
                Some(value) => Ok(format!("Value: {}", value)),
                None => Ok(format!("Key '{}' not found", key)),
            }
        }
        Command::Set { key, value } => {
            database.set(key.clone(), value);
            Ok(format!("Key '{}' set", key))
        }
        Command::Delete { key } => {
            if database.delete(&key) {
                Ok(format!("Key '{}' deleted", key))
            } else {
                Ok(format!("Key '{}' not found", key))
            }
        }
        Command::List { prefix } => {
            let keys = match prefix {
                Some(p) => database.list_with_prefix(&p),
                None => database.list_all(),
            };
            Ok(format!("Keys: {:?}", keys))
        }
        Command::Quit => {
            Ok("Goodbye!".to_string())
        }
    }
}
```

## Заключение

Выражение `match` в Rust - это мощный и гибкий инструмент для сопоставления с образцами и обработки различных вариантов данных. Оно имеет ряд особенностей, отличающих его от аналогичных конструкций в других языках:

1. Исчерпывающая проверка всех возможных вариантов
2. Возможность деструктуризации сложных типов данных
3. Поддержка охранных выражений и связывания переменных
4. Оптимизации компилятора для эффективного выполнения

Эффективное использование выражения `match` - важный навык для разработчика на Rust, позволяющий писать более читаемый, безопасный и выразительный код.
