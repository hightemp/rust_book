# Паника и восстановление

В этой главе мы рассмотрим один из механизмов обработки ошибок в Rust - панику. Паника - это способ реагирования программы на неисправимые ошибки, которые делают невозможным дальнейшее выполнение программы в нормальном режиме.

## Что такое паника в Rust?

Паника (panic) в Rust - это механизм, который программа использует, когда сталкивается с непоправимой ошибкой. Когда происходит паника:

1. Программа начинает "разворачивать стек" (unwinding the stack)
2. Очищает данные из каждого кадра стека
3. Завершает выполнение текущего потока или всей программы
4. Выводит сообщение об ошибке и трассировку стека

Паника предназначена для обработки исключительных ситуаций, которые не должны возникать в нормальных условиях работы программы и от которых программа не может корректно восстановиться.

## Когда происходит паника?

Паника может возникнуть в следующих случаях:

1. **Явный вызов `panic!`**: Когда разработчик сам вызывает макрос `panic!`
2. **Ошибки времени выполнения**: Например, при доступе к элементу массива по несуществующему индексу
3. **Ассерты**: При невыполнении условия в макросе `assert!`
4. **Невосстановимые ошибки в стандартной библиотеке**: Например, при попытке создать поток, когда система не может выделить ресурсы

## Макрос `panic!`

Самый простой способ вызвать панику - использовать макрос `panic!`:

```rust
fn main() {
    panic!("Произошла критическая ошибка!");
}
```

При выполнении этого кода программа завершится с сообщением об ошибке:

```
thread 'main' panicked at 'Произошла критическая ошибка!', src/main.rs:2:5
```

## Паника при ошибках времени выполнения

Rust автоматически вызывает панику в некоторых ситуациях, например, при доступе к элементу массива по индексу, выходящему за границы:

```rust
fn main() {
    let v = vec![1, 2, 3];
    let value = v[99]; // Это вызовет панику
}
```

Результат:

```
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:3:17
```

## Трассировка стека при панике

Когда происходит паника, Rust выводит трассировку стека (stack backtrace) - список всех функций, которые были вызваны до момента возникновения паники. Это помогает определить, где именно произошла ошибка.

Чтобы увидеть полную трассировку стека, нужно установить переменную окружения `RUST_BACKTRACE=1`:

```bash
$ RUST_BACKTRACE=1 cargo run
```

## Два режима обработки паники

В Rust существует два режима обработки паники:

1. **Разворачивание стека (unwinding)** - режим по умолчанию, при котором Rust очищает данные из каждого кадра стека перед завершением программы
2. **Аварийное завершение (abort)** - программа немедленно завершается без очистки ресурсов

Режим можно выбрать в файле `Cargo.toml`:

```toml
[profile.release]
panic = "abort"
```

## Восстановление после паники с помощью `std::panic::catch_unwind`

В некоторых случаях может потребоваться перехватить панику и продолжить выполнение программы. Для этого в Rust есть функция `std::panic::catch_unwind`:

```rust
use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        println!("Привет из безопасного кода");
        panic!("О нет, произошла паника!");
    });

    match result {
        Ok(_) => println!("Операция выполнена успешно"),
        Err(_) => println!("Операция завершилась паникой, но мы перехватили её")
    }

    println!("Программа продолжает работу");
}
```

Вывод:

```
Привет из безопасного кода
Операция завершилась паникой, но мы перехватили её
Программа продолжает работу
```

Важно отметить, что `catch_unwind` работает только в режиме разворачивания стека (unwinding). Если программа настроена на аварийное завершение (abort), то `catch_unwind` не сможет перехватить панику.

## Когда использовать `catch_unwind`

Функция `catch_unwind` предназначена не для обычной обработки ошибок, а для специфических случаев:

1. **Взаимодействие с кодом на других языках**: Когда Rust-код вызывается из C/C++, паника не должна пересекать границу FFI
2. **Многопоточные программы**: Чтобы паника в одном потоке не приводила к завершению всей программы
3. **Тестирование**: Для проверки, что определенный код вызывает панику

Для обычной обработки ошибок в Rust рекомендуется использовать тип `Result<T, E>`, который мы рассмотрим в следующем разделе.

## Функция `std::panic::resume_unwind`

Если вам нужно перехватить панику, выполнить какие-то действия, а затем продолжить разворачивание стека, можно использовать `std::panic::resume_unwind`:

```rust
use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        panic!("Первоначальная паника");
    });

    if let Err(panic_payload) = result {
        println!("Выполняем действия перед повторной паникой");
        panic::resume_unwind(panic_payload);
    }
}
```

## Хук паники

Rust позволяет установить собственный обработчик паники с помощью функции `std::panic::set_hook`:

```rust
use std::panic;

fn main() {
    panic::set_hook(Box::new(|panic_info| {
        println!("Программа запаниковала: {}", panic_info);
        // Здесь можно добавить логирование, отправку уведомлений и т.д.
    }));

    panic!("Тестовая паника");
}
```

Это полезно для логирования паник или отправки отчетов об ошибках.

## Когда использовать панику

Паника в Rust должна использоваться только в исключительных ситуациях:

1. **Невосстановимые ошибки**: Когда программа оказывается в состоянии, из которого невозможно корректно продолжить работу
2. **Нарушение инвариантов**: Когда обнаруживается, что важные инварианты программы нарушены
3. **Примеры и прототипы**: В учебном коде или быстрых прототипах, где полноценная обработка ошибок избыточна
4. **Тесты**: В тестах для проверки, что код корректно обрабатывает ошибочные ситуации

В большинстве случаев для обработки ошибок следует использовать тип `Result<T, E>`, который позволяет явно обрабатывать ошибки и делает код более надежным.

## Практические рекомендации

1. **Используйте панику редко**: Паника должна быть последним средством, когда другие механизмы обработки ошибок не подходят
2. **Документируйте функции, которые могут паниковать**: Если ваша функция может вызвать панику, укажите это в документации
3. **Предпочитайте `Result` вместо паники**: Для большинства ошибок лучше использовать `Result<T, E>`
4. **Используйте `unwrap()` и `expect()` только в прототипах или тестах**: В продакшн-коде избегайте этих методов, так как они могут вызвать панику

## Заключение

Паника в Rust - это механизм для обработки критических, невосстановимых ошибок. Хотя Rust предоставляет способы перехвата и восстановления после паники, в большинстве случаев для обработки ошибок следует использовать тип `Result<T, E>`, который мы рассмотрим в следующем разделе.

Паника должна использоваться только в исключительных ситуациях, когда продолжение выполнения программы невозможно или может привести к серьезным проблемам безопасности или целостности данных.