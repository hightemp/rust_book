# Кортежи (Tuples) в Rust

Кортежи - это один из составных типов данных в Rust, который позволяет группировать несколько значений разных типов в одну составную единицу. В отличие от массивов, которые могут содержать только элементы одного типа, кортежи могут содержать элементы разных типов, что делает их очень гибкими для хранения связанных данных.

## Объявление и инициализация кортежей

Кортеж в Rust объявляется с помощью круглых скобок `()`, внутри которых перечисляются значения, разделенные запятыми:

```rust
// Кортеж, содержащий целое число, булево значение и строку
let tuple = (42, true, "hello");

// Кортеж с явным указанием типов
let explicit_tuple: (i32, bool, &str) = (42, true, "hello");

// Пустой кортеж, также известный как unit-тип
let empty_tuple = ();
```

Пустой кортеж `()` имеет особое значение в Rust и называется unit-типом. Он используется, когда функция не возвращает значение (аналогично `void` в других языках).

## Доступ к элементам кортежа

Существует несколько способов получить доступ к элементам кортежа:

### 1. Индексация с помощью точки

Можно обращаться к элементам кортежа по их индексу, используя синтаксис `.N`, где N - это индекс элемента (начиная с 0):

```rust
let tuple = (500, 6.4, "Rust");

let first = tuple.0;  // 500
let second = tuple.1; // 6.4
let third = tuple.2;  // "Rust"

println!("Значения: {}, {}, {}", first, second, third);
```

### 2. Деструктуризация

Rust позволяет извлекать значения из кортежа с помощью деструктуризации:

```rust
let tuple = (500, 6.4, "Rust");

// Деструктуризация кортежа
let (x, y, z) = tuple;

println!("x = {}, y = {}, z = {}", x, y, z);
```

Если вам нужны только некоторые элементы кортежа, можно использовать символ подчеркивания `_` для игнорирования ненужных элементов:

```rust
let tuple = (500, 6.4, "Rust", true);

// Извлекаем только первый и третий элементы
let (first, _, third, _) = tuple;

println!("Первый: {}, Третий: {}", first, third);
```

## Возвращение нескольких значений из функции

Одно из распространенных применений кортежей - возвращение нескольких значений из функции:

```rust
fn calculate_statistics(numbers: &[i32]) -> (i32, i32, f64) {
    let sum: i32 = numbers.iter().sum();
    let max = *numbers.iter().max().unwrap_or(&0);
    let average = sum as f64 / numbers.len() as f64;
    
    // Возвращаем кортеж с суммой, максимальным значением и средним
    (sum, max, average)
}

fn main() {
    let numbers = [1, 5, 10, 2, 7];
    
    // Получаем результат в виде кортежа
    let stats = calculate_statistics(&numbers);
    println!("Сумма: {}, Максимум: {}, Среднее: {:.2}", stats.0, stats.1, stats.2);
    
    // Или с использованием деструктуризации
    let (sum, max, avg) = calculate_statistics(&numbers);
    println!("Сумма: {}, Максимум: {}, Среднее: {:.2}", sum, max, avg);
}
```

## Вложенные кортежи

Кортежи могут содержать другие кортежи, создавая вложенные структуры:

```rust
let nested_tuple = (1, (2.0, 3.0), ("hello", "world"));

// Доступ к элементам вложенного кортежа
let x = nested_tuple.1.0;  // 2.0
let greeting = nested_tuple.2.0;  // "hello"

println!("x = {}, greeting = {}", x, greeting);
```

## Сравнение кортежей

Кортежи можно сравнивать, если все их элементы можно сравнивать. Сравнение выполняется поэлементно, начиная с первого элемента:

```rust
let tuple1 = (1, 2, 3);
let tuple2 = (1, 3, 2);
let tuple3 = (1, 2, 3);

println!("tuple1 == tuple2: {}", tuple1 == tuple2);  // false
println!("tuple1 == tuple3: {}", tuple1 == tuple3);  // true
println!("tuple1 < tuple2: {}", tuple1 < tuple2);    // true (1 == 1, но 2 < 3)
```

## Одноэлементные кортежи

Для создания кортежа с одним элементом необходимо добавить запятую после значения, чтобы отличить его от выражения в скобках:

```rust
// Это кортеж с одним элементом
let single_tuple = (42,);
println!("Одноэлементный кортеж: {:?}", single_tuple);

// Это просто число в скобках, не кортеж
let not_a_tuple = (42);
println!("Не кортеж: {}", not_a_tuple);
```

## Когда использовать кортежи

Кортежи особенно полезны в следующих случаях:

1. **Возвращение нескольких значений из функции**, когда не требуется именованная структура.
2. **Временное группирование связанных значений**, когда не нужно создавать отдельный тип.
3. **Передача нескольких параметров как единого аргумента**.

Однако, если вам нужно работать с более сложными структурами данных или если семантика полей важна, лучше использовать структуры (`struct`), которые позволяют давать имена полям.

## Ограничения кортежей

Основные ограничения кортежей:

1. **Отсутствие именованных полей** - доступ по индексу менее читабельный, чем доступ по имени поля.
2. **Ограниченная расширяемость** - сложно добавлять или удалять элементы без изменения всего кода, который использует кортеж.
3. **Кортежи с большим количеством элементов** становятся трудными для понимания и поддержки.

## Примеры использования кортежей

### Пример 1: Разбор строки на компоненты

```rust
fn parse_coordinates(input: &str) -> Option<(f64, f64)> {
    let parts: Vec<&str> = input.split(',').collect();
    
    if parts.len() != 2 {
        return None;
    }
    
    let x = parts[0].trim().parse::<f64>().ok()?;
    let y = parts[1].trim().parse::<f64>().ok()?;
    
    Some((x, y))
}

fn main() {
    let input = "10.5, 20.3";
    
    if let Some((x, y)) = parse_coordinates(input) {
        println!("Координаты: x = {}, y = {}", x, y);
    } else {
        println!("Ошибка при разборе координат");
    }
}
```

### Пример 2: Использование кортежей с итераторами

```rust
fn main() {
    let names = vec!["Alice", "Bob", "Charlie"];
    let ages = vec![25, 30, 35];
    
    // Создаем итератор пар (имя, возраст)
    let people = names.iter().zip(ages.iter());
    
    for (name, age) in people {
        println!("{} is {} years old", name, age);
    }
    
    // Использование enumerate() для получения индекса и значения
    let fruits = vec!["Apple", "Banana", "Cherry"];
    
    for (index, fruit) in fruits.iter().enumerate() {
        println!("Fruit #{}: {}", index + 1, fruit);
    }
}
```

### Пример 3: Использование кортежей в HashMap

```rust
use std::collections::HashMap;

fn main() {
    // Используем кортеж в качестве ключа в HashMap
    let mut scores = HashMap::new();
    
    // Кортеж (имя, предмет) как ключ
    scores.insert(("Alice", "Math"), 95);
    scores.insert(("Alice", "Physics"), 87);
    scores.insert(("Bob", "Math"), 80);
    scores.insert(("Bob", "Physics"), 92);
    
    // Поиск по кортежу
    let alice_math_score = scores.get(&("Alice", "Math"));
    
    if let Some(score) = alice_math_score {
        println!("Alice's Math score: {}", score);
    }
    
    // Перебор всех записей
    for ((name, subject), score) in &scores {
        println!("{}'s {} score: {}", name, subject, score);
    }
}
```

## Заключение

Кортежи в Rust - это простой, но мощный способ группировки разнотипных данных. Они особенно полезны для возвращения нескольких значений из функций и временного хранения связанных данных. Однако для более сложных структур данных с именованными полями лучше использовать структуры (`struct`).

Понимание кортежей и умение эффективно их использовать - важный навык для программирования на Rust, который поможет писать более чистый и выразительный код.