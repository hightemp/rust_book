# Концепция владения (ownership) в Rust

Система владения (ownership) - это одна из наиболее уникальных и мощных особенностей языка Rust. Она позволяет Rust гарантировать безопасность памяти без использования сборщика мусора, что делает язык одновременно безопасным и высокопроизводительным.

## Что такое владение?

Владение - это набор правил, которые управляют тем, как программа Rust управляет памятью. Все программы должны управлять использованием компьютерной памяти во время выполнения. Некоторые языки имеют сборщик мусора, который постоянно ищет неиспользуемую память (например, Java, Python). В других языках программист должен явно выделять и освобождать память (например, C, C++). 

Rust использует третий подход: память управляется через систему владения с набором правил, которые проверяются компилятором. Если какое-либо из правил нарушается, программа не скомпилируется.

## Основные правила владения

В Rust действуют три основных правила владения:

1. Каждое значение в Rust имеет переменную, которая называется его **владельцем**.
2. В каждый момент времени может быть только один владелец.
3. Когда владелец выходит из области видимости, значение будет удалено.

Давайте рассмотрим эти правила на примерах.

## Область видимости

Область видимости - это диапазон в программе, в котором элемент действителен. Рассмотрим простой пример:

```rust
{                      // s здесь недействителен, он еще не объявлен
    let s = "hello";   // s действителен с этого момента
    
    // можно использовать s
}                      // эта область видимости закончилась, s больше недействителен
```

Переменная `s` действительна с момента ее объявления до конца текущей области видимости.

## Типы данных и владение

В Rust типы данных делятся на две категории с точки зрения владения:

1. **Типы с известным размером**, которые хранятся в стеке (stack): целые числа, числа с плавающей точкой, булевы значения, символы и т.д.
2. **Типы с неизвестным или изменяемым размером**, которые хранятся в куче (heap): строки, векторы, структуры и т.д.

Для типов, хранящихся в стеке, Rust использует механизм копирования (copy). Для типов, хранящихся в куче, Rust использует механизм перемещения (move).

### Типы с копированием (Copy)

Рассмотрим пример с целыми числами:

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

Здесь `x` и `y` - это два независимых значения `5`, хранящихся в стеке. После присваивания `y = x` обе переменные можно использовать, потому что целые числа имеют фиксированный размер и реализуют трейт `Copy`.

### Типы с перемещением (Move)

Теперь рассмотрим пример со строкой:

```rust
let s1 = String::from("hello");
let s2 = s1;

// println!("{}", s1); // Ошибка! s1 больше не действителен
println!("{}", s2);    // Работает
```

Когда мы присваиваем `s1` переменной `s2`, данные строки не копируются. Вместо этого Rust перемещает владение от `s1` к `s2`, и `s1` становится недействительным. Это предотвращает проблему "двойного освобождения" памяти, когда две переменные пытаются освободить одну и ту же память.

## Функции и владение

Передача значения в функцию работает аналогично присваиванию. Функция может:

1. **Взять владение** значением (move)
2. **Заимствовать** значение (borrow)
3. **Вернуть владение** обратно

Пример передачи владения:

```rust
fn main() {
    let s = String::from("hello");
    
    takes_ownership(s);
    
    // println!("{}", s); // Ошибка! s больше не действителен
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // some_string выходит из области видимости и память освобождается
```

Пример возврата владения:

```rust
fn main() {
    let s1 = gives_ownership();
    
    let s2 = String::from("hello");
    
    let s3 = takes_and_gives_back(s2);
    
    // println!("{}", s2); // Ошибка! s2 больше не действителен
    println!("{}, {}", s1, s3); // Работает
}

fn gives_ownership() -> String {
    let some_string = String::from("hello");
    some_string // возвращаем владение вызывающей стороне
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string // возвращаем владение вызывающей стороне
}
```

## Возврат нескольких значений

Если функция берет владение значением, но мы хотим использовать это значение после вызова функции, мы можем вернуть значение обратно. Однако это может быть неудобно. Rust позволяет возвращать несколько значений с помощью кортежей:

```rust
fn main() {
    let s1 = String::from("hello");
    
    let (s2, len) = calculate_length(s1);
    
    println!("Длина строки '{}' равна {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();
    
    (s, length) // возвращаем кортеж с строкой и ее длиной
}
```

Однако это все еще не очень удобно. В следующей теме мы рассмотрим концепцию заимствования (borrowing), которая решает эту проблему более элегантно.

## Преимущества системы владения

Система владения в Rust обеспечивает несколько важных преимуществ:

1. **Безопасность памяти**: Предотвращает ошибки, связанные с использованием памяти, такие как висячие указатели, двойное освобождение и утечки памяти.

2. **Отсутствие сборщика мусора**: Rust не требует сборщика мусора, что делает его более производительным и предсказуемым.

3. **Детерминированное освобождение ресурсов**: Ресурсы освобождаются, как только их владелец выходит из области видимости, что делает управление ресурсами более предсказуемым.

4. **Параллельное программирование**: Система владения помогает предотвратить гонки данных и другие проблемы параллельного программирования.

## Заключение

Система владения - это фундаментальная концепция Rust, которая обеспечивает безопасность памяти без использования сборщика мусора. Она основана на трех простых правилах:

1. Каждое значение имеет одного владельца.
2. В каждый момент времени может быть только один владелец.
3. Когда владелец выходит из области видимости, значение удаляется.

Эти правила могут показаться ограничивающими, но они обеспечивают безопасность и эффективность программ на Rust. В следующих темах мы рассмотрим концепции заимствования и времен жизни, которые делают систему владения более гибкой и удобной в использовании.