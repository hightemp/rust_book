# Разделяемое состояние

## Введение

Разделяемое состояние — это подход к многопоточному программированию, при котором несколько потоков имеют доступ к одним и тем же данным. В отличие от передачи сообщений, где данные перемещаются между потоками, при использовании разделяемого состояния данные остаются на месте, а потоки получают к ним доступ.

В Rust разделяемое состояние реализуется с помощью различных примитивов синхронизации, которые обеспечивают безопасный доступ к общим данным.

## Проблемы разделяемого состояния

При использовании разделяемого состояния возникают следующие проблемы:

1. **Гонки данных**: Когда несколько потоков одновременно обращаются к одним и тем же данным, и хотя бы один из них выполняет запись.
2. **Взаимные блокировки (deadlocks)**: Когда два или более потоков ждут друг друга, чтобы освободить ресурсы.
3. **Живые блокировки (livelocks)**: Когда потоки активно выполняются, но не продвигаются в своей работе.
4. **Инверсия приоритетов**: Когда поток с высоким приоритетом ждет ресурс, удерживаемый потоком с низким приоритетом.

Rust помогает решить эти проблемы с помощью своей системы типов и примитивов синхронизации.

## Атомарные типы

Атомарные типы предоставляют операции, которые гарантированно выполняются атомарно, без прерываний со стороны других потоков. Они находятся в модуле `std::sync::atomic`.

### Основные атомарные типы

- `AtomicBool`: атомарный булев тип
- `AtomicI8`, `AtomicI16`, `AtomicI32`, `AtomicI64`, `AtomicIsize`: атомарные целые числа со знаком
- `AtomicU8`, `AtomicU16`, `AtomicU32`, `AtomicU64`, `AtomicUsize`: атомарные целые числа без знака
- `AtomicPtr<T>`: атомарный указатель

### Пример использования AtomicBool

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;
use std::time::Duration;

fn main() {
    // Создаем атомарный булев тип, инициализированный значением false
    let running = AtomicBool::new(true);
    
    // Создаем ссылку, которую можно безопасно передать в другой поток
    let running_ref = &running;
    
    // Создаем поток, который будет периодически проверять значение running
    let handle = thread::spawn(move || {
        let mut counter = 0;
        
        // Цикл будет выполняться, пока running == true
        while running_ref.load(Ordering::Relaxed) {
            counter += 1;
            println!("Работаем... Счетчик: {}", counter);
            thread::sleep(Duration::from_millis(500));
        }
        
        println!("Поток завершил работу. Итоговый счетчик: {}", counter);
    });
    
    // Даем потоку поработать некоторое время
    thread::sleep(Duration::from_secs(3));
    
    // Устанавливаем running в false, чтобы остановить поток
    running.store(false, Ordering::Relaxed);
    println!("Основной поток установил running в false");
    
    // Ожидаем завершения потока
    handle.join().unwrap();
}
```

### Порядок памяти (Memory Ordering)

При работе с атомарными типами важно указывать порядок памяти, который определяет, как операции с памятью упорядочиваются относительно друг друга:

- `Ordering::Relaxed`: самый слабый порядок, гарантирует только атомарность операции
- `Ordering::Release`: все операции с памятью до этой операции будут видны после этой операции
- `Ordering::Acquire`: все операции с памятью после этой операции будут видеть все операции до соответствующей операции Release
- `Ordering::AcqRel`: комбинация Acquire и Release
- `Ordering::SeqCst`: самый строгий порядок, гарантирует полную последовательную согласованность

### Пример использования AtomicUsize с разными порядками памяти

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

fn main() {
    let counter = AtomicUsize::new(0);
    
    let mut handles = vec![];
    
    // Создаем 10 потоков, каждый из которых увеличивает счетчик 1000 раз
    for _ in 0..10 {
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                // Атомарно увеличиваем счетчик на 1
                counter.fetch_add(1, Ordering::SeqCst);
            }
        });
        
        handles.push(handle);
    }
    
    // Ожидаем завершения всех потоков
    for handle in handles {
        handle.join().unwrap();
    }
    
    // Выводим итоговое значение счетчика
    println!("Итоговое значение счетчика: {}", counter.load(Ordering::SeqCst));
}
```

## Arc (Atomic Reference Counted)

`Arc<T>` — это тип, который обеспечивает разделяемое владение значением типа `T`, размещенным в куче. Внутренний счетчик ссылок увеличивается и уменьшается атомарно, что делает `Arc<T>` безопасным для использования в многопоточном контексте.

### Пример использования Arc

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    // Создаем Arc с данными
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    
    let mut handles = vec![];
    
    // Создаем 5 потоков, каждый из которых имеет доступ к данным
    for i in 0..5 {
        // Клонируем Arc, увеличивая счетчик ссылок
        let data_clone = Arc::clone(&data);
        
        let handle = thread::spawn(move || {
            println!("Поток {}: данные = {:?}", i, data_clone);
        });
        
        handles.push(handle);
    }
    
    // Ожидаем завершения всех потоков
    for handle in handles {
        handle.join().unwrap();
    }
    
    // Когда data выходит из области видимости, счетчик ссылок уменьшается.
    // Когда счетчик достигает 0, данные освобождаются.
}
```

### Arc с изменяемыми данными

Сам по себе `Arc<T>` не позволяет изменять данные, так как он предоставляет только разделяемые ссылки (`&T`). Для изменяемого доступа необходимо использовать его в сочетании с примитивами синхронизации, такими как `Mutex` или `RwLock`.

## Mutex (Mutual Exclusion)

`Mutex<T>` — это примитив синхронизации, который обеспечивает взаимное исключение доступа к данным типа `T`. В каждый момент времени только один поток может иметь доступ к данным, защищенным мьютексом.

### Пример использования Mutex

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // Создаем Mutex, содержащий счетчик
    let counter = Arc::new(Mutex::new(0));
    
    let mut handles = vec![];
    
    // Создаем 10 потоков, каждый из которых увеличивает счетчик 1000 раз
    for i in 0..10 {
        let counter_clone = Arc::clone(&counter);
        
        let handle = thread::spawn(move || {
            for j in 0..1000 {
                // Блокируем мьютекс и получаем доступ к данным
                let mut num = counter_clone.lock().unwrap();
                *num += 1;
                
                // Мьютекс автоматически освобождается, когда num выходит из области видимости
                if i == 0 && j % 100 == 0 {
                    println!("Поток 0: счетчик = {}", *num);
                }
            }
        });
        
        handles.push(handle);
    }
    
    // Ожидаем завершения всех потоков
    for handle in handles {
        handle.join().unwrap();
    }
    
    // Выводим итоговое значение счетчика
    println!("Итоговое значение счетчика: {}", *counter.lock().unwrap());
}
```

### Особенности Mutex

1. **Блокирующий характер**: `lock()` блокирует поток до тех пор, пока мьютекс не станет доступным.
2. **Отравление (Poisoning)**: Если поток запаникует, удерживая мьютекс, мьютекс считается "отравленным". Метод `lock()` возвращает `Result`, который будет содержать `Err`, если мьютекс отравлен.
3. **Автоматическое освобождение**: Мьютекс автоматически освобождается, когда защищенные данные выходят из области видимости.

### Обработка отравления мьютекса

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(0));
    
    let data_clone = Arc::clone(&data);
    let handle = thread::spawn(move || {
        // Блокируем мьютекс
        let mut num = data_clone.lock().unwrap();
        *num += 1;
        
        // Паникуем, удерживая мьютекс
        panic!("Ой, что-то пошло не так!");
    });
    
    // Игнорируем результат join, так как поток запаниковал
    let _ = handle.join();
    
    // Пытаемся заблокировать мьютекс после паники
    match data.lock() {
        Ok(mut num) => {
            println!("Мьютекс не отравлен, значение: {}", *num);
            *num += 1;
        },
        Err(poisoned) => {
            // Получаем доступ к данным, даже если мьютекс отравлен
            let mut num = poisoned.into_inner();
            println!("Мьютекс отравлен, но мы все равно получили доступ к данным: {}", *num);
            *num += 1;
        }
    }
    
    // Выводим итоговое значение
    println!("Итоговое значение: {}", *data.lock().unwrap());
}
```

## RwLock (Read-Write Lock)

`RwLock<T>` — это примитив синхронизации, который позволяет нескольким потокам одновременно читать данные, но только одному потоку записывать. Это полезно, когда операции чтения выполняются чаще, чем операции записи.

### Пример использования RwLock

```rust
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;

fn main() {
    // Создаем RwLock, содержащий вектор
    let data = Arc::new(RwLock::new(vec![1, 2, 3, 4, 5]));
    
    // Создаем поток для записи
    let data_clone = Arc::clone(&data);
    let writer = thread::spawn(move || {
        // Имитация работы
        thread::sleep(Duration::from_millis(500));
        
        // Блокируем RwLock для записи
        println!("Поток-писатель пытается получить доступ на запись...");
        let mut data = data_clone.write().unwrap();
        println!("Поток-писатель получил доступ на запись");
        
        // Изменяем данные
        data.push(6);
        data.push(7);
        
        // Имитация длительной операции записи
        thread::sleep(Duration::from_secs(2));
        
        println!("Поток-писатель завершил запись: {:?}", *data);
        // RwLock автоматически освобождается, когда data выходит из области видимости
    });
    
    // Создаем несколько потоков для чтения
    let mut readers = vec![];
    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        
        let reader = thread::spawn(move || {
            // Имитация работы
            thread::sleep(Duration::from_millis(i * 300));
            
            // Блокируем RwLock для чтения
            println!("Поток-читатель {} пытается получить доступ на чтение...", i);
            let data = data_clone.read().unwrap();
            println!("Поток-читатель {} получил доступ на чтение: {:?}", i, *data);
            
            // Имитация длительной операции чтения
            thread::sleep(Duration::from_secs(1));
            
            println!("Поток-читатель {} завершил чтение", i);
            // RwLock автоматически освобождается, когда data выходит из области видимости
        });
        
        readers.push(reader);
    }
    
    // Ожидаем завершения всех потоков
    for reader in readers {
        reader.join().unwrap();
    }
    
    writer.join().unwrap();
    
    // Выводим итоговое значение
    println!("Итоговое значение: {:?}", *data.read().unwrap());
}
```

### Особенности RwLock

1. **Приоритет**: В некоторых реализациях операции записи имеют приоритет над операциями чтения, чтобы избежать "голодания" писателей.
2. **Блокирующий характер**: `read()` и `write()` блокируют поток до тех пор, пока соответствующий доступ не станет возможным.
3. **Отравление**: Как и `Mutex`, `RwLock` может быть отравлен, если поток запаникует, удерживая блокировку.

## Условные переменные (Condvar)

`Condvar` — это примитив синхронизации, который позволяет потокам ждать, пока не произойдет определенное событие. Обычно используется в сочетании с `Mutex`.

### Пример использования Condvar

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;
use std::time::Duration;

fn main() {
    // Создаем пару Mutex и Condvar
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    
    // Клонируем Arc для использования в другом потоке
    let pair_clone = Arc::clone(&pair);
    
    // Создаем поток, который будет ждать сигнала
    let handle = thread::spawn(move || {
        let (lock, cvar) = &*pair_clone;
        
        // Блокируем мьютекс и получаем доступ к данным
        let mut started = lock.lock().unwrap();
        
        println!("Поток ожидает сигнала...");
        
        // Пока started == false, ждем сигнала
        while !*started {
            // wait временно освобождает мьютекс и блокирует поток
            // Когда поток разблокируется, мьютекс снова блокируется
            started = cvar.wait(started).unwrap();
        }
        
        println!("Поток получил сигнал и продолжает работу!");
    });
    
    // Имитация работы
    thread::sleep(Duration::from_secs(2));
    
    // Отправляем сигнал
    let (lock, cvar) = &*pair;
    let mut started = lock.lock().unwrap();
    *started = true;
    println!("Основной поток отправляет сигнал");
    cvar.notify_one();
    
    // Ожидаем завершения потока
    handle.join().unwrap();
}
```

### Особенности Condvar

1. **Ложные пробуждения**: Поток может быть разбужен, даже если условие не выполнено, поэтому всегда проверяйте условие в цикле.
2. **Методы уведомления**:
   - `notify_one()`: разбудить один ожидающий поток
   - `notify_all()`: разбудить все ожидающие потоки
3. **Методы ожидания**:
   - `wait()`: ждать без таймаута
   - `wait_timeout()`: ждать с таймаутом
   - `wait_while()`: ждать, пока предикат возвращает true

## Барьеры (Barrier)

`Barrier` — это примитив синхронизации, который позволяет нескольким потокам ждать друг друга в определенной точке выполнения.

### Пример использования Barrier

```rust
use std::sync::{Arc, Barrier};
use std::thread;
use std::time::Duration;

fn main() {
    let num_threads = 5;
    let barrier = Arc::new(Barrier::new(num_threads));
    
    let mut handles = vec![];
    
    for i in 0..num_threads {
        let barrier_clone = Arc::clone(&barrier);
        
        let handle = thread::spawn(move || {
            println!("Поток {} начал работу", i);
            
            // Имитация работы разной продолжительности
            thread::sleep(Duration::from_millis(i * 200));
            
            println!("Поток {} готов и ждет остальные", i);
            
            // Ждем, пока все потоки достигнут этой точки
            let wait_result = barrier_clone.wait();
            
            // Один из потоков получит true, остальные - false
            if wait_result.is_leader() {
                println!("Поток {} является лидером", i);
            }
            
            println!("Поток {} продолжает работу после барьера", i);
        });
        
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### Особенности Barrier

1. **Повторное использование**: Барьер можно использовать повторно после того, как все потоки его преодолели.
2. **Лидер**: Один из потоков назначается "лидером" и может выполнять специальные действия.
3. **Динамическое количество потоков**: Можно изменять количество потоков, которые должны достичь барьера, с помощью метода `reset()`.

## Однократная инициализация (Once)

`Once` — это примитив синхронизации, который гарантирует, что определенный код будет выполнен только один раз, даже если к нему обращаются из нескольких потоков.

### Пример использования Once

```rust
use std::sync::{Arc, Once};
use std::thread;

// Глобальная переменная Once
static INIT: Once = Once::new();

fn main() {
    let mut handles = vec![];
    
    for i in 0..10 {
        let handle = thread::spawn(move || {
            // Этот код будет выполнен только один раз, независимо от того,
            // сколько потоков вызывают call_once
            INIT.call_once(|| {
                println!("Инициализация выполнена потоком {}", i);
            });
            
            println!("Поток {} после инициализации", i);
        });
        
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### Особенности Once

1. **Безопасность**: `Once` гарантирует, что инициализация будет выполнена только один раз, даже в условиях гонки потоков.
2. **Блокировка**: Если один поток выполняет инициализацию, другие потоки будут заблокированы до ее завершения.
3. **Паника**: Если инициализация запаникует, `Once` считается не выполненным, и следующий вызов `call_once` попытается выполнить инициализацию снова.

## Лучшие практики работы с разделяемым состоянием

1. **Минимизируйте область блокировки**: Держите мьютексы заблокированными как можно меньше времени.
2. **Избегайте вложенных блокировок**: Вложенные блокировки могут привести к взаимным блокировкам.
3. **Используйте подходящие примитивы**: Выбирайте правильный примитив синхронизации для конкретной задачи.
4. **Предпочитайте атомарные операции**: Когда возможно, используйте атомарные типы вместо мьютексов.
5. **Будьте осторожны с условными переменными**: Всегда проверяйте условие в цикле из-за возможности ложных пробуждений.
6. **Используйте Arc для разделяемого владения**: Когда несколько потоков должны иметь доступ к одним и тем же данным, используйте `Arc`.

## Заключение

Rust предоставляет богатый набор примитивов синхронизации для работы с разделяемым состоянием в многопоточных программах. Благодаря системе типов Rust, многие ошибки многопоточного программирования обнаруживаются на этапе компиляции. Атомарные типы, `Arc`, `Mutex`, `RwLock` и другие примитивы позволяют эффективно организовать доступ к общим данным, избегая распространенных проблем, таких как гонки данных и взаимные блокировки.

В следующем разделе мы рассмотрим мьютексы и другие примитивы синхронизации более подробно, а также изучим более сложные сценарии их использования.