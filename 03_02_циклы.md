# Циклы (loop, while, for) в Rust

## Введение

Циклы - фундаментальный механизм управления потоком выполнения программы, позволяющий многократно выполнять блок кода. В Rust реализованы три основных типа циклов: `loop`, `while` и `for`, каждый из которых имеет свои особенности и области применения.

В этой главе мы подробно рассмотрим все типы циклов в Rust, их синтаксис, особенности реализации, продвинутые случаи использования и оптимизации компилятора.

## Цикл loop

Цикл `loop` - это простейший тип цикла в Rust, который выполняет блок кода бесконечно, пока не встретит оператор `break`.

### Базовый синтаксис

```rust
loop {
    // Код, выполняемый в цикле
    
    if условие {
        break; // Выход из цикла
    }
}
```

### Возвращение значений из цикла loop

Одна из особенностей Rust - возможность возвращать значение из цикла `loop` с помощью оператора `break`:

```rust
let result = loop {
    // Код цикла
    
    if условие {
        break значение; // Выход из цикла с возвращением значения
    }
};
```

Пример:

```rust
let mut counter = 0;

let result = loop {
    counter += 1;
    
    if counter == 10 {
        break counter * 2; // Возвращаем значение 20
    }
};

println!("Результат: {}", result); // Выведет: "Результат: 20"
```

### Вложенные циклы и метки

Для управления вложенными циклами Rust поддерживает метки (labels), которые позволяют указать, из какого именно цикла нужно выйти:

```rust
'outer: loop {
    println!("Внешний цикл");
    
    'inner: loop {
        println!("Внутренний цикл");
        
        // Выход из внутреннего цикла
        break 'inner;
        
        // Выход из внешнего цикла
        // break 'outer;
    }
}
```

Метки также работают с оператором `continue`:

```rust
'outer: loop {
    let mut i = 0;
    
    'inner: loop {
        i += 1;
        
        if i % 2 == 0 {
            continue 'inner; // Пропускаем четные числа
        }
        
        println!("i = {}", i);
        
        if i > 5 {
            break 'outer; // Выход из внешнего цикла
        }
    }
}
```

### Использование loop для повторных попыток

Цикл `loop` часто используется для повторных попыток выполнения операции, которая может завершиться неудачей:

```rust
let result = loop {
    match некоторая_операция() {
        Ok(value) => break value, // Успешное выполнение
        Err(error) => {
            if можно_повторить(error) {
                println!("Повторная попытка...");
                continue; // Повторяем операцию
            } else {
                break Err(error); // Невосстановимая ошибка
            }
        }
    }
};
```

## Цикл while

Цикл `while` выполняет блок кода, пока указанное условие истинно.

### Базовый синтаксис

```rust
while условие {
    // Код, выполняемый в цикле
}
```

Пример:

```rust
let mut number = 3;

while number != 0 {
    println!("{}!", number);
    number -= 1;
}

println!("LIFTOFF!!!");
```

### Сравнение с loop

Цикл `while` можно рассматривать как сокращенную запись цикла `loop` с проверкой условия и оператором `break`:

```rust
// Цикл while
while условие {
    // Тело цикла
}

// Эквивалентный цикл loop
loop {
    if !условие {
        break;
    }
    
    // Тело цикла
}
```

Однако цикл `while` более читаемый и выразительный для случаев, когда условие выхода известно заранее.

### Особенности условий в while

Как и в случае с условными выражениями `if`, условие в цикле `while` должно иметь тип `bool`. Rust не выполняет неявное приведение типов к булевым значениям:

```rust
let mut x = 5;

// Правильно
while x > 0 {
    println!("x = {}", x);
    x -= 1;
}

// Неправильно, не скомпилируется
// while x { // x не является булевым значением
//     println!("x = {}", x);
//     x -= 1;
// }
```

### while let

Аналогично конструкции `if let`, Rust предоставляет `while let`, которая объединяет цикл `while` с сопоставлением с образцом:

```rust
let mut stack = Vec::new();
stack.push(1);
stack.push(2);
stack.push(3);

// Извлекаем элементы из стека, пока он не пуст
while let Some(top) = stack.pop() {
    println!("Верхний элемент: {}", top);
}
```

Это особенно полезно при работе с итераторами, которые возвращают `Option` или `Result`.

## Цикл for

Цикл `for` в Rust используется для итерации по элементам коллекций или других итерируемых объектов.

### Базовый синтаксис

```rust
for переменная in итерируемый_объект {
    // Код, выполняемый для каждого элемента
}
```

Пример:

```rust
let numbers = [10, 20, 30, 40, 50];

for number in numbers {
    println!("Значение: {}", number);
}
```

### Итерация по диапазонам

Для итерации по диапазону чисел в Rust используется оператор диапазона `..` или `..=`:

```rust
// Полуоткрытый диапазон (не включает верхнюю границу)
for i in 1..5 {
    println!("i = {}", i); // Выведет числа 1, 2, 3, 4
}

// Закрытый диапазон (включает верхнюю границу)
for i in 1..=5 {
    println!("i = {}", i); // Выведет числа 1, 2, 3, 4, 5
}
```

### Итерация с индексами

Для итерации с доступом к индексам можно использовать метод `enumerate()`:

```rust
let fruits = ["яблоко", "банан", "апельсин"];

for (index, fruit) in fruits.iter().enumerate() {
    println!("Фрукт {} находится на позиции {}", fruit, index);
}
```

### Итерация по ссылкам

При итерации по коллекции можно использовать различные методы для управления владением:

```rust
let numbers = vec![1, 2, 3, 4, 5];

// Итерация по значениям (перемещение)
for number in numbers {
    println!("Значение: {}", number);
}
// После этого numbers больше недоступен, так как значения перемещены

let numbers = vec![1, 2, 3, 4, 5];

// Итерация по ссылкам (заимствование)
for number in &numbers {
    println!("Ссылка: {}", number);
}
// numbers все еще доступен

// Итерация по изменяемым ссылкам
for number in &mut numbers {
    *number *= 2; // Изменяем значение
    println!("Изменено: {}", number);
}
```

## Итераторы в Rust

Цикл `for` в Rust тесно связан с концепцией итераторов. Итератор - это объект, реализующий трейт `Iterator`, который определяет метод `next()` для последовательного доступа к элементам.

### Трейт Iterator

```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
    // ... другие методы с реализацией по умолчанию
}
```

Метод `next()` возвращает `Some(item)` для следующего элемента или `None`, когда элементы закончились.

### Создание итераторов

Для создания итератора из коллекции используются методы:

- `iter()` - создает итератор по ссылкам на элементы
- `iter_mut()` - создает итератор по изменяемым ссылкам
- `into_iter()` - создает итератор, который потребляет коллекцию

```rust
let v = vec![1, 2, 3];

// Итератор по ссылкам
let iter = v.iter();
for i in iter {
    println!("Ссылка: {}", i);
}

// Итератор по изменяемым ссылкам
let mut v = vec![1, 2, 3];
let iter_mut = v.iter_mut();
for i in iter_mut {
    *i += 10;
}

// Итератор, потребляющий коллекцию
let v = vec![1, 2, 3];
let into_iter = v.into_iter();
for i in into_iter {
    println!("Значение: {}", i);
}
// v больше недоступен
```

### Преобразование цикла for в итераторы

Компилятор Rust преобразует цикл `for` в использование итераторов. Следующий код:

```rust
for val in collection {
    println!("{}", val);
}
```

Примерно эквивалентен:

```rust
let mut iterator = collection.into_iter();
while let Some(val) = iterator.next() {
    println!("{}", val);
}
```

### Методы итераторов

Трейт `Iterator` предоставляет множество полезных методов для работы с последовательностями:

- `map()` - преобразует элементы
- `filter()` - фильтрует элементы по условию
- `fold()` - сворачивает последовательность в одно значение
- `collect()` - собирает элементы в коллекцию
- и многие другие

```rust
let numbers = vec![1, 2, 3, 4, 5];

// Цепочка методов итератора
let sum: i32 = numbers
    .iter()
    .filter(|&x| x % 2 == 0) // Только четные числа
    .map(|&x| x * x)         // Возведение в квадрат
    .sum();                  // Суммирование

println!("Сумма квадратов четных чисел: {}", sum); // 20 (2² + 4²)
```

## Особенности реализации циклов в Rust

### Компиляция циклов

На уровне LLVM IR циклы в Rust компилируются в инструкции условного и безусловного перехода. Компилятор Rust выполняет ряд оптимизаций:

1. **Разворачивание циклов (loop unrolling)**: для небольших циклов с известным количеством итераций компилятор может развернуть цикл, заменив его на последовательность операций без переходов

```rust
// Исходный код
for i in 0..4 {
    println!("{}", i);
}

// После разворачивания (концептуально)
println!("0");
println!("1");
println!("2");
println!("3");
```

2. **Векторизация**: компилятор может преобразовать цикл в векторные инструкции, которые обрабатывают несколько элементов за одну операцию

3. **Удаление инвариантов цикла**: выражения, не изменяющиеся внутри цикла, могут быть вынесены за его пределы

### Оптимизация итераторов

Rust использует концепцию "нулевой стоимости абстракций" (zero-cost abstractions), что означает, что высокоуровневые абстракции, такие как итераторы, компилируются в код, сравнимый по эффективности с низкоуровневыми циклами.

```rust
// Высокоуровневый код с итераторами
let sum: i32 = (0..1000).filter(|&x| x % 2 == 0).sum();

// Компилируется в эффективный машинный код, сравнимый с:
let mut sum = 0;
for i in 0..1000 {
    if i % 2 == 0 {
        sum += i;
    }
}
```

## Продвинутые случаи использования

### Бесконечные итераторы

Rust позволяет создавать бесконечные итераторы, которые никогда не возвращают `None`:

```rust
// Бесконечный итератор, генерирующий последовательность чисел
let natural_numbers = std::iter::successors(Some(1), |&n| Some(n + 1));

// Берем только первые 10 чисел
for n in natural_numbers.take(10) {
    println!("{}", n);
}
```

### Комбинирование итераторов

Итераторы можно комбинировать различными способами:

```rust
let v1 = vec![1, 2, 3];
let v2 = vec![4, 5, 6];

// Объединение итераторов
for x in v1.iter().chain(v2.iter()) {
    println!("{}", x); // Выведет 1, 2, 3, 4, 5, 6
}

// Зип-итератор (комбинирует элементы попарно)
for (x, y) in v1.iter().zip(v2.iter()) {
    println!("({}, {})", x, y); // Выведет (1, 4), (2, 5), (3, 6)
}
```

### Итераторы и замыкания

Итераторы часто используются с замыканиями для создания гибких и выразительных преобразований данных:

```rust
let numbers = vec![1, 2, 3, 4, 5];

// Использование замыканий с захватом переменных из окружения
let threshold = 3;
let filtered: Vec<_> = numbers
    .iter()
    .filter(|&&x| x > threshold)
    .map(|&x| x * 2)
    .collect();

println!("Отфильтрованные и удвоенные: {:?}", filtered); // [8, 10]
```

### Итераторы и параллелизм

С помощью библиотеки `rayon` можно легко преобразовать последовательные итераторы в параллельные:

```rust
use rayon::prelude::*;

let numbers: Vec<i32> = (0..1000000).collect();

// Последовательная обработка
let sum_sequential: i32 = numbers.iter().filter(|&&x| x % 2 == 0).sum();

// Параллельная обработка
let sum_parallel: i32 = numbers.par_iter().filter(|&&x| x % 2 == 0).sum();

assert_eq!(sum_sequential, sum_parallel);
```

## Оптимизации компилятора

### Автовекторизация

Современные компиляторы, включая Rust, могут автоматически векторизовать циклы, используя SIMD-инструкции (Single Instruction, Multiple Data) для параллельной обработки нескольких элементов:

```rust
fn sum_array(arr: &[f32]) -> f32 {
    let mut sum = 0.0;
    for &x in arr {
        sum += x;
    }
    sum
}
```

Этот код может быть автоматически векторизован компилятором для использования SIMD-инструкций, таких как AVX или SSE.

### Оптимизация граничных проверок

Rust выполняет проверку границ массивов во время выполнения, но компилятор может устранять избыточные проверки:

```rust
fn sum_array(arr: &[i32]) -> i32 {
    let mut sum = 0;
    for i in 0..arr.len() {
        sum += arr[i]; // Проверка границ здесь
    }
    sum
}
```

Компилятор может определить, что индекс `i` всегда находится в пределах массива, и устранить избыточные проверки границ.

### Инлайнинг итераторов

Компилятор Rust может встраивать (inline) методы итераторов, устраняя накладные расходы на вызовы функций:

```rust
let sum: i32 = (0..1000).filter(|&x| x % 2 == 0).sum();
```

После оптимизации этот код может быть эквивалентен простому циклу без вызовов функций.

## Примеры реальных сценариев использования

### Обработка коллекций

Циклы и итераторы часто используются для обработки коллекций данных:

```rust
struct User {
    id: u32,
    name: String,
    active: bool,
}

fn get_active_user_names(users: &[User]) -> Vec<&str> {
    users
        .iter()
        .filter(|user| user.active)
        .map(|user| user.name.as_str())
        .collect()
}
```

### Обработка потоков данных

Итераторы эффективны для обработки потоков данных, таких как чтение файлов:

```rust
use std::fs::File;
use std::io::{self, BufRead, BufReader};

fn count_lines_with_word(filename: &str, word: &str) -> io::Result<usize> {
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    
    let count = reader
        .lines()
        .filter_map(Result::ok)
        .filter(|line| line.contains(word))
        .count();
    
    Ok(count)
}
```

### Генерация последовательностей

Итераторы могут использоваться для генерации последовательностей данных:

```rust
// Генерация последовательности Фибоначчи
fn fibonacci() -> impl Iterator<Item = u64> {
    let mut a = 0;
    let mut b = 1;
    
    std::iter::from_fn(move || {
        let current = a;
        a = b;
        b = current + b;
        Some(current)
    })
}

// Использование
for n in fibonacci().take(10) {
    println!("{}", n); // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
}
```

### Конвейерная обработка данных

Итераторы позволяют создавать эффективные конвейеры обработки данных:

```rust
fn process_log_file(filename: &str) -> io::Result<Vec<LogEntry>> {
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    
    let entries = reader
        .lines()
        .filter_map(Result::ok)
        .filter(|line| !line.starts_with('#')) // Пропускаем комментарии
        .filter_map(|line| parse_log_entry(&line)) // Парсим строки в структуры
        .filter(|entry| entry.level >= LogLevel::Warning) // Фильтруем по уровню
        .take(1000) // Ограничиваем количество записей
        .collect();
    
    Ok(entries)
}
```

## Сравнение циклов и выбор подходящего типа

### Когда использовать loop

- Когда нужен бесконечный цикл или цикл с неизвестным заранее количеством итераций
- Когда требуется возвращать значение из цикла
- Для реализации повторных попыток выполнения операции

### Когда использовать while

- Когда условие выхода из цикла известно заранее
- Когда условие должно проверяться перед каждой итерацией
- Для простых циклов с счетчиком

### Когда использовать for

- Для итерации по элементам коллекции
- Для итерации по диапазону чисел
- Когда нужно применить преобразования к элементам последовательности

### Когда использовать итераторы напрямую

- Для сложных преобразований данных с использованием методов итераторов
- Для создания ленивых вычислений, которые выполняются только при необходимости
- Для комбинирования нескольких источников данных

## Заключение

Циклы в Rust - это мощный и гибкий инструмент для управления потоком выполнения программы. Они имеют ряд особенностей, отличающих их от аналогичных конструкций в других языках:

1. Цикл `loop` может возвращать значения
2. Поддержка меток для управления вложенными циклами
3. Тесная интеграция с системой типов и проверкой границ
4. Богатая экосистема итераторов с множеством методов преобразования
5. Оптимизации компилятора, обеспечивающие эффективное выполнение

Эффективное использование циклов и итераторов - важный навык для разработчика на Rust, позволяющий писать безопасный, производительный и выразительный код.