# Компиляция и запуск программ в Rust

## Введение

Компиляция и запуск программ — это фундаментальные процессы в разработке на Rust. В этом разделе мы подробно рассмотрим различные способы компиляции и запуска программ, параметры компиляции, оптимизации и другие важные аспекты этих процессов.

## Компиляция программ на Rust

Rust — это компилируемый язык, что означает, что исходный код должен быть преобразован в исполняемый файл перед запуском. Для компиляции программ на Rust можно использовать два основных инструмента:

1. **rustc** — компилятор Rust
2. **Cargo** — система сборки и менеджер пакетов для Rust

### Компиляция с помощью rustc

`rustc` — это базовый компилятор Rust, который преобразует исходный код в исполняемый файл. Хотя в большинстве случаев вы будете использовать Cargo, понимание работы с `rustc` полезно для более глубокого понимания процесса компиляции.

#### Простая компиляция

Для компиляции простой программы используйте:

```bash
rustc main.rs
```

Эта команда скомпилирует файл `main.rs` и создаст исполняемый файл с именем `main` (или `main.exe` в Windows).

#### Параметры компилятора rustc

Компилятор `rustc` имеет множество параметров:

- `-o <имя>` — задает имя выходного файла
- `--edition=<edition>` — указывает редакцию Rust (2015, 2018, 2021)
- `-g` — включает отладочную информацию
- `-O` — включает оптимизации
- `--target=<target>` — указывает целевую платформу для кросс-компиляции
- `--emit=<тип>` — указывает тип выходных данных (asm, llvm-ir, mir и т.д.)
- `-C <опция>` — передает опции кодогенерации

Пример использования параметров:

```bash
rustc -o my_program -g -O main.rs
```

Эта команда скомпилирует `main.rs` с оптимизациями и отладочной информацией и создаст исполняемый файл с именем `my_program`.

#### Вывод промежуточного представления

Для анализа и отладки можно вывести промежуточное представление кода:

```bash
# Вывод LLVM IR
rustc --emit=llvm-ir main.rs

# Вывод ассемблерного кода
rustc --emit=asm main.rs

# Вывод MIR (среднее представление Rust)
rustc -Z unpretty=mir main.rs
```

### Компиляция с помощью Cargo

Cargo — это предпочтительный способ компиляции программ на Rust, так как он автоматически управляет зависимостями и предоставляет множество удобных функций.

#### Основные команды Cargo для компиляции

- `cargo build` — компилирует проект
- `cargo build --release` — компилирует проект с оптимизациями для релиза
- `cargo check` — проверяет, компилируется ли код, без создания исполняемого файла
- `cargo run` — компилирует и запускает проект
- `cargo run --release` — компилирует с оптимизациями и запускает проект

#### Профили сборки

Cargo поддерживает различные профили сборки, которые можно настроить в файле `Cargo.toml`:

```toml
[profile.dev]
opt-level = 0        # Уровень оптимизации (0-3)
debug = true         # Включение отладочной информации
debug-assertions = true  # Включение отладочных утверждений
overflow-checks = true   # Проверка переполнения
lto = false          # Link Time Optimization
panic = 'unwind'     # Стратегия обработки паники
incremental = true   # Инкрементальная компиляция
codegen-units = 16   # Количество единиц кодогенерации

[profile.release]
opt-level = 3
debug = false
debug-assertions = false
overflow-checks = false
lto = false
panic = 'unwind'
incremental = false
codegen-units = 16

[profile.test]
opt-level = 0
debug = 2
debug-assertions = true
overflow-checks = true
lto = false
panic = 'unwind'
incremental = true
codegen-units = 16

[profile.bench]
opt-level = 3
debug = false
debug-assertions = false
overflow-checks = false
lto = false
panic = 'unwind'
incremental = false
codegen-units = 16
```

#### Параметры компиляции Cargo

Cargo позволяет передавать параметры компилятору `rustc`:

```bash
cargo build --verbose -- -C target-cpu=native
```

Также можно настроить параметры компиляции в файле `.cargo/config.toml`:

```toml
[build]
rustflags = ["-C", "target-cpu=native"]
```

#### Условная компиляция

Rust поддерживает условную компиляцию с помощью атрибутов и флагов функций:

```rust
// Компилируется только для Windows
#[cfg(target_os = "windows")]
fn windows_only() {
    println!("Эта функция доступна только на Windows");
}

// Компилируется только при включенной функции "feature1"
#[cfg(feature = "feature1")]
fn feature1_function() {
    println!("Функция feature1 включена");
}
```

Для включения функций при компиляции:

```bash
cargo build --features "feature1 feature2"
```

## Процесс компиляции Rust

Процесс компиляции Rust состоит из нескольких этапов:

1. **Лексический анализ и парсинг** — преобразование исходного кода в абстрактное синтаксическое дерево (AST)
2. **Проверка типов и заимствований** — анализ типов и проверка правил владения и заимствования
3. **Преобразование в MIR** — преобразование AST в среднее представление Rust (MIR)
4. **Оптимизация MIR** — оптимизация кода на уровне MIR
5. **Генерация LLVM IR** — преобразование MIR в промежуточное представление LLVM
6. **Оптимизация LLVM** — оптимизация кода на уровне LLVM
7. **Генерация машинного кода** — преобразование LLVM IR в машинный код
8. **Линковка** — объединение объектных файлов и библиотек в исполняемый файл

### Инкрементальная компиляция

Rust поддерживает инкрементальную компиляцию, которая позволяет перекомпилировать только измененные части кода, что значительно ускоряет процесс разработки. Инкрементальная компиляция включена по умолчанию в профиле `dev`.

### Параллельная компиляция

Cargo автоматически использует параллельную компиляцию для ускорения процесса. Количество параллельных задач можно настроить с помощью переменной среды `CARGO_BUILD_JOBS` или параметра `-j`:

```bash
cargo build -j 4  # Использовать 4 потока для компиляции
```

## Оптимизации

Rust предоставляет различные уровни оптимизации, которые можно настроить с помощью параметра `opt-level`:

- **0** — без оптимизаций, быстрая компиляция, хорошо для разработки
- **1** — базовые оптимизации, компромисс между скоростью компиляции и производительностью
- **2** — все оптимизации, кроме самых тяжелых
- **3** — все возможные оптимизации, максимальная производительность
- **"s"** — оптимизация размера, минимизирует размер бинарного файла
- **"z"** — еще более агрессивная оптимизация размера

Пример настройки в `Cargo.toml`:

```toml
[profile.release]
opt-level = 3  # Максимальная оптимизация производительности
```

### Link Time Optimization (LTO)

LTO — это оптимизация, которая выполняется на этапе линковки и может значительно улучшить производительность за счет оптимизации между модулями:

```toml
[profile.release]
lto = true  # Включить LTO
```

Доступны различные уровни LTO:

```toml
[profile.release]
lto = "thin"  # Быстрая LTO
# или
lto = "fat"   # Полная LTO (эквивалентно lto = true)
```

### Оптимизация для конкретного процессора

Можно оптимизировать код для конкретной архитектуры процессора:

```bash
RUSTFLAGS="-C target-cpu=native" cargo build --release
```

Или в `.cargo/config.toml`:

```toml
[build]
rustflags = ["-C", "target-cpu=native"]
```

### Профилирование и оптимизация

Для профилирования и оптимизации кода можно использовать различные инструменты:

- **perf** — профилировщик для Linux
- **Instruments** — профилировщик для macOS
- **Windows Performance Analyzer** — профилировщик для Windows
- **flamegraph** — визуализация результатов профилирования

Пример использования perf:

```bash
cargo build --release
perf record -g ./target/release/my_program
perf report
```

## Запуск программ

После компиляции программу можно запустить несколькими способами.

### Запуск скомпилированного исполняемого файла

```bash
# Если скомпилировано с помощью rustc
./main

# Если скомпилировано с помощью Cargo
./target/debug/my_program
./target/release/my_program
```

### Запуск с помощью Cargo

```bash
# Запуск в режиме отладки
cargo run

# Запуск в режиме релиза
cargo run --release

# Запуск с аргументами командной строки
cargo run -- arg1 arg2 arg3
```

### Запуск с переменными среды

```bash
# Установка переменных среды перед запуском
RUST_LOG=debug cargo run

# Или для исполняемого файла
RUST_LOG=debug ./target/debug/my_program
```

## Кросс-компиляция

Кросс-компиляция позволяет компилировать программы для платформы, отличной от текущей.

### Установка целевой платформы

```bash
rustup target add x86_64-pc-windows-gnu
rustup target add aarch64-unknown-linux-gnu
rustup target add wasm32-unknown-unknown
```

### Компиляция для целевой платформы

```bash
cargo build --target x86_64-pc-windows-gnu
cargo build --target aarch64-unknown-linux-gnu
cargo build --target wasm32-unknown-unknown
```

### Настройка линкера для кросс-компиляции

Для кросс-компиляции может потребоваться настройка линкера в файле `.cargo/config.toml`:

```toml
[target.aarch64-unknown-linux-gnu]
linker = "aarch64-linux-gnu-gcc"
```

## Отладка программ

Rust поддерживает отладку с помощью стандартных отладчиков, таких как GDB и LLDB.

### Компиляция с отладочной информацией

```bash
# С помощью rustc
rustc -g main.rs

# С помощью Cargo (по умолчанию в режиме debug)
cargo build
```

### Отладка с помощью GDB

```bash
gdb ./target/debug/my_program
```

Основные команды GDB:
- `break <функция или строка>` — установка точки останова
- `run [аргументы]` — запуск программы
- `next` — выполнение следующей строки
- `step` — шаг с заходом в функцию
- `print <выражение>` — вывод значения выражения
- `backtrace` — вывод стека вызовов
- `continue` — продолжение выполнения

### Отладка с помощью LLDB

```bash
lldb ./target/debug/my_program
```

Основные команды LLDB аналогичны командам GDB.

### Отладка в IDE

Большинство современных IDE, таких как Visual Studio Code, CLion и IntelliJ IDEA с плагином Rust, поддерживают отладку программ на Rust с графическим интерфейсом.

## Анализ производительности

### Бенчмаркинг

Rust предоставляет встроенную поддержку бенчмаркинга через атрибут `#[bench]`:

```rust
#![feature(test)]
extern crate test;

use test::Bencher;

#[bench]
fn bench_add(b: &mut Bencher) {
    b.iter(|| {
        // Код, производительность которого нужно измерить
        1 + 1
    });
}
```

Для запуска бенчмарков:

```bash
cargo bench
```

### Criterion.rs

Для более продвинутого бенчмаркинга можно использовать библиотеку Criterion.rs:

```toml
[dev-dependencies]
criterion = "0.3"

[[bench]]
name = "my_benchmark"
harness = false
```

Пример бенчмарка с Criterion:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 1,
        n => fibonacci(n-1) + fibonacci(n-2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

## Управление памятью и производительностью

### Профилирование памяти

Для профилирования использования памяти можно использовать инструменты, такие как Valgrind и DHAT:

```bash
valgrind --tool=massif ./target/release/my_program
ms_print massif.out.<pid>
```

### Оптимизация использования памяти

Rust предоставляет различные типы для оптимизации использования памяти:

- `Box<T>` — для размещения данных в куче
- `Rc<T>` и `Arc<T>` — для разделяемого владения
- `&T` и `&mut T` — для заимствования без владения

### Избегание аллокаций

Для повышения производительности можно минимизировать аллокации:

- Использовать типы с фиксированным размером, такие как массивы, вместо векторов, где это возможно
- Использовать `String::with_capacity()` и `Vec::with_capacity()` для предварительного выделения памяти
- Повторно использовать буферы вместо создания новых

## Практические примеры

### Пример 1: Компиляция и запуск простой программы

Создайте файл `hello.rs`:

```rust
fn main() {
    println!("Привет, мир!");
}
```

Компиляция и запуск с помощью rustc:

```bash
rustc hello.rs
./hello
```

Компиляция и запуск с помощью Cargo:

```bash
# Создание нового проекта
cargo new hello_cargo
cd hello_cargo

# Редактирование src/main.rs (если нужно)

# Компиляция и запуск
cargo run
```

### Пример 2: Оптимизация программы

Создайте файл `Cargo.toml` с настройками оптимизации:

```toml
[package]
name = "optimized_app"
version = "0.1.0"
edition = "2021"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"
strip = true  # Удаление символов отладки
```

Компиляция и запуск оптимизированной программы:

```bash
cargo build --release
./target/release/optimized_app
```

### Пример 3: Кросс-компиляция для Windows из Linux

Установка целевой платформы:

```bash
rustup target add x86_64-pc-windows-gnu
```

Настройка линкера в `.cargo/config.toml`:

```toml
[target.x86_64-pc-windows-gnu]
linker = "x86_64-w64-mingw32-gcc"
```

Компиляция:

```bash
cargo build --release --target x86_64-pc-windows-gnu
```

### Пример 4: Отладка программы

Создайте программу с ошибкой:

```rust
fn main() {
    let v = vec![1, 2, 3];
    println!("{}", v[5]); // Ошибка: индекс за пределами массива
}
```

Компиляция и отладка:

```bash
cargo build
gdb ./target/debug/my_program

# В GDB:
run
backtrace
```

## Заключение

Компиляция и запуск программ — это фундаментальные процессы в разработке на Rust. Понимание различных аспектов этих процессов, таких как оптимизации, отладка и профилирование, позволяет создавать более эффективные и надежные программы.

В этом разделе мы рассмотрели различные способы компиляции и запуска программ на Rust, параметры компиляции, оптимизации, отладку и профилирование. Эти знания помогут вам более эффективно разрабатывать программы на Rust и решать возникающие проблемы.

## Дополнительные ресурсы

- [Документация Rust по компиляции](https://doc.rust-lang.org/rustc/index.html)
- [Руководство по оптимизации в Rust](https://nnethercote.github.io/perf-book/)
- [Документация Cargo](https://doc.rust-lang.org/cargo/)
- [Профилирование программ на Rust](https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html)
- [Кросс-компиляция в Rust](https://rust-lang.github.io/rustup/cross-compilation.html)