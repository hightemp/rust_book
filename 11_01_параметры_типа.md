# Параметры типа в Rust

Параметры типа (type parameters) - это один из фундаментальных механизмов обобщенного программирования в Rust, который позволяет писать код, работающий с различными типами данных. Вместо создания отдельных функций или структур для каждого конкретного типа, мы можем использовать параметры типа для создания обобщенного (generic) кода.

## Зачем нужны параметры типа?

Представьте, что вам нужно написать функцию, которая находит наибольшее значение в массиве. Без обобщенного программирования вам пришлось бы создавать отдельные функции для каждого типа данных:

```rust
fn find_largest_i32(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn find_largest_char(list: &[char]) -> &char {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```

Заметьте, что эти функции практически идентичны, отличаясь только типом данных. Это нарушает принцип DRY (Don't Repeat Yourself) и усложняет поддержку кода.

С помощью параметров типа мы можем создать одну обобщенную функцию:

```rust
fn find_largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```

## Синтаксис параметров типа

Параметры типа в Rust объявляются в угловых скобках `<>` после имени функции, структуры или перечисления. Обычно используются однобуквенные имена, начиная с `T` (от слова "Type"):

```rust
fn some_function<T>(param: T) {
    // Тело функции
}
```

Здесь `T` - это параметр типа, который может быть заменен любым конкретным типом при вызове функции.

## Множественные параметры типа

Функция или структура может иметь несколько параметров типа:

```rust
fn some_function<T, U>(t: T, u: U) -> i32 {
    // Тело функции
}
```

В этом примере `T` и `U` - это два разных параметра типа, которые могут быть заменены любыми конкретными типами.

## Вывод типов

Rust обладает мощной системой вывода типов, которая часто может определить конкретные типы для параметров типа на основе аргументов, переданных функции:

```rust
fn identity<T>(x: T) -> T {
    x
}

fn main() {
    let integer = identity(5);       // T выводится как i32
    let float = identity(5.0);       // T выводится как f64
    let string = identity("hello");  // T выводится как &str
}
```

## Параметры типа в методах

Параметры типа могут использоваться не только в функциях, но и в методах:

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}
```

Обратите внимание на синтаксис `impl<T> Point<T>`. Здесь мы сначала объявляем параметр типа `T`, а затем указываем, что реализуем методы для типа `Point<T>`.

## Параметры типа с разными типами

В структуре `Point` выше оба поля `x` и `y` должны иметь один и тот же тип `T`. Если мы хотим, чтобы они могли иметь разные типы, мы можем использовать несколько параметров типа:

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn x(&self) -> &T {
        &self.x
    }
    
    fn y(&self) -> &U {
        &self.y
    }
}
```

Теперь мы можем создать точку с координатами разных типов:

```rust
let point = Point { x: 5, y: 4.0 };  // x имеет тип i32, y имеет тип f64
```

## Параметры типа в методах, отличные от параметров типа структуры

Методы могут иметь свои собственные параметры типа, которые отличаются от параметров типа структуры:

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}
```

В этом примере метод `mixup` имеет свои собственные параметры типа `V` и `W`, которые отличаются от параметров типа `T` и `U` структуры `Point`.

## Конкретизация параметров типа

Иногда мы хотим реализовать методы только для конкретных типов. Это можно сделать, указав конкретный тип вместо параметра типа:

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

Этот метод будет доступен только для `Point<f32>`, но не для других типов, таких как `Point<i32>` или `Point<String>`.

## Производительность обобщенного кода

Важно отметить, что использование параметров типа в Rust не приводит к снижению производительности во время выполнения. Это достигается благодаря процессу, называемому мономорфизацией (monomorphization).

Во время компиляции Rust генерирует отдельные версии обобщенных функций и структур для каждого конкретного типа, с которым они используются. Таким образом, вызов обобщенной функции с конкретным типом так же эффективен, как если бы функция была написана специально для этого типа.

## Заключение

Параметры типа - это мощный инструмент в Rust, который позволяет писать гибкий, повторно используемый код без потери производительности. Они являются основой для обобщенного программирования и используются во многих стандартных библиотеках и крейтах Rust.

В следующем разделе мы рассмотрим, как использовать параметры типа для создания обобщенных функций, и как ограничивать параметры типа с помощью трейтов для обеспечения определенного поведения.