# Концепция заимствования (borrowing)

Заимствование (borrowing) - это один из фундаментальных механизмов в Rust, который тесно связан с системой владения. Этот механизм позволяет получить доступ к данным без передачи права владения, что делает код более гибким и эффективным.

## Что такое заимствование?

В предыдущей главе мы изучили концепцию владения (ownership), которая является основой управления памятью в Rust. Мы узнали, что каждое значение в Rust имеет переменную, которая является его "владельцем", и что в каждый момент времени может существовать только один владелец. Когда владелец выходит из области видимости, значение уничтожается.

Однако часто нам нужно использовать значение, не становясь его владельцем. Например, мы можем хотеть передать значение в функцию для обработки, но при этом сохранить возможность использовать это значение после вызова функции. Именно для этого в Rust существует механизм заимствования.

**Заимствование** позволяет временно получить доступ к значению без передачи права владения. Это достигается с помощью **ссылок** (references).

## Ссылки в Rust

Ссылка в Rust - это указатель на значение, которым владеет другая переменная. В отличие от владения, когда вы создаете ссылку на значение, вы не становитесь его владельцем и не отвечаете за его уничтожение.

Ссылки создаются с помощью оператора `&`:

```rust
fn main() {
    let s1 = String::from("привет");
    
    // Создаем ссылку на s1
    let s1_ref = &s1;
    
    println!("Значение по ссылке: {}", s1_ref);
    
    // s1 все еще доступна, так как мы только заимствовали ее
    println!("Оригинальное значение: {}", s1);
}
```

В этом примере `s1_ref` - это ссылка на строку `s1`. Мы можем использовать `s1_ref` для доступа к значению `s1`, но `s1_ref` не владеет этим значением. Когда `s1_ref` выходит из области видимости, значение не уничтожается, так как `s1` все еще является владельцем.

## Заимствование в функциях

Одно из наиболее распространенных применений заимствования - это передача аргументов в функции. Вместо передачи значения по владению, мы можем передать ссылку на это значение:

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s1 = String::from("привет");
    
    let len = calculate_length(&s1);
    
    println!("Длина строки '{}' равна {}.", s1, len);
}
```

В этом примере функция `calculate_length` принимает ссылку на `String` (`&String`), а не сам `String`. Это означает, что функция заимствует значение, а не становится его владельцем. После вызова функции `s1` все еще доступна в `main`, так как право владения не было передано.

## Разыменование ссылок

Когда у вас есть ссылка, вы можете получить доступ к значению, на которое она указывает, с помощью оператора разыменования `*`. Однако в большинстве случаев Rust автоматически разыменовывает ссылки при доступе к полям или методам:

```rust
fn main() {
    let x = 5;
    let y = &x;
    
    assert_eq!(5, x);
    assert_eq!(5, *y); // Явное разыменование
    
    let s = String::from("привет");
    let s_ref = &s;
    
    // Автоматическое разыменование при вызове метода
    println!("Длина: {}", s_ref.len());
}
```

## Заимствование и время жизни

Важно понимать, что ссылка не может существовать дольше, чем значение, на которое она указывает. Rust гарантирует, что ссылки всегда указывают на действительные данные, предотвращая проблему "висячих указателей" (dangling pointers).

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // Эта функция возвращает ссылку на String
    let s = String::from("привет"); // s создается внутри функции
    &s // Возвращаем ссылку на s
} // s выходит из области видимости и уничтожается, ссылка становится недействительной
```

Этот код не скомпилируется, потому что функция `dangle` пытается вернуть ссылку на `String`, который будет уничтожен при выходе из функции. Rust предотвращает такие ошибки на этапе компиляции.

## Преимущества заимствования

Заимствование имеет несколько важных преимуществ:

1. **Эффективность**: Нет необходимости копировать или клонировать данные, что экономит память и время выполнения.
2. **Гибкость**: Можно использовать значение в нескольких местах без передачи владения.
3. **Безопасность**: Компилятор Rust гарантирует, что ссылки всегда указывают на действительные данные.

## Заключение

Заимствование - это мощный механизм в Rust, который дополняет систему владения, делая код более гибким и эффективным. С помощью ссылок мы можем временно получить доступ к значениям без передачи права владения, что позволяет использовать одни и те же данные в разных частях программы.

В следующем разделе мы рассмотрим изменяемые и неизменяемые ссылки, а также правила, которые Rust применяет к заимствованию для обеспечения безопасности памяти.

## Практические примеры

### Пример 1: Заимствование в функциях

```rust
fn print_info(name: &String, age: &i32) {
    println!("Имя: {}, Возраст: {}", name, age);
}

fn main() {
    let name = String::from("Анна");
    let age = 30;
    
    print_info(&name, &age);
    
    // name и age все еще доступны
    println!("После вызова функции: {} - {}", name, age);
}
```

### Пример 2: Заимствование в циклах

```rust
fn main() {
    let names = vec![
        String::from("Алексей"),
        String::from("Мария"),
        String::from("Иван")
    ];
    
    // Заимствуем каждый элемент вектора для печати
    for name in &names {
        println!("Имя: {}", name);
    }
    
    // Вектор names все еще доступен
    println!("Всего имен: {}", names.len());
}
```

### Пример 3: Заимствование структур

```rust
struct Person {
    name: String,
    age: u32,
}

fn display_person(person: &Person) {
    println!("Имя: {}, Возраст: {}", person.name, person.age);
}

fn main() {
    let person = Person {
        name: String::from("Елена"),
        age: 25,
    };
    
    display_person(&person);
    
    // person все еще доступна
    println!("Человек {} все еще здесь!", person.name);
}