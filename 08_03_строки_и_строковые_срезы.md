# Строки и строковые срезы в Rust

Работа со строками - одна из наиболее распространенных задач в программировании. В Rust строки реализованы несколько иначе, чем во многих других языках, что обусловлено фокусом языка на безопасности памяти и корректной работе с Unicode. В этой главе мы рассмотрим два основных строковых типа в Rust: `String` и `&str` (строковый срез), их особенности, различия и способы эффективного использования.

## Строковые срезы (&str)

Строковый срез (`&str`) - это ссылка на последовательность символов UTF-8, хранящуюся где-то в памяти. Это неизменяемый (immutable) "вид" на строковые данные.

### Строковые литералы

Строковые литералы в Rust имеют тип `&str`:

```rust
let greeting = "Привет, мир!"; // greeting имеет тип &str
```

Строковые литералы хранятся в бинарном файле программы и являются срезами, указывающими на эту область памяти. Они всегда имеют статическое время жизни (`'static`), что означает, что они существуют на протяжении всего времени выполнения программы:

```rust
let lifetime_example: &'static str = "У меня статическое время жизни";
```

### Создание строковых срезов

Строковые срезы можно создавать не только из литералов, но и из других строк:

```rust
let s = String::from("привет мир");

// Создание среза всей строки
let s1 = &s[..]; // "привет мир"

// Создание среза части строки
let hello = &s[0..12]; // "привет"
let world = &s[13..]; // "мир"
```

**Важно**: При создании срезов строк необходимо учитывать, что индексы должны находиться на границах символов UTF-8. В противном случае программа вызовет панику во время выполнения.

## Тип String

`String` - это изменяемый, владеющий своими данными тип строки, который хранится в куче. Он представляет собой обертку над вектором байтов (`Vec<u8>`), гарантирующую, что содержимое всегда является валидной последовательностью UTF-8.

### Создание String

Существует несколько способов создания значения типа `String`:

```rust
// Создание пустой строки
let mut empty_string = String::new();

// Создание из строкового литерала
let s = String::from("Привет");

// Использование метода to_string()
let s = "Привет".to_string();

// Использование макроса format!
let s = format!("Привет, {}!", "мир");
```

### Изменение String

В отличие от `&str`, тип `String` можно изменять, если он объявлен как изменяемый (`mut`):

```rust
let mut s = String::from("Привет");

// Добавление строки в конец
s.push_str(", мир!");

// Добавление одного символа
s.push('!');

println!("{}", s); // Выведет: "Привет, мир!!"
```

### Конкатенация строк

Rust предлагает несколько способов объединения строк:

#### 1. Оператор `+`

```rust
let s1 = String::from("Привет, ");
let s2 = String::from("мир!");
let s3 = s1 + &s2; // Обратите внимание, что s1 перемещается и больше не доступна

println!("{}", s3); // "Привет, мир!"
// println!("{}", s1); // Ошибка: s1 была перемещена
println!("{}", s2); // "мир!" - s2 все еще доступна
```

Оператор `+` использует метод `add`, который имеет примерно такую сигнатуру:
```rust
fn add(self, s: &str) -> String
```

Это означает, что первый аргумент (`self`) передается по значению и, следовательно, перемещается.

#### 2. Макрос `format!`

Более гибкий и удобный способ объединения строк - использование макроса `format!`:

```rust
let s1 = String::from("Привет");
let s2 = String::from("мир");
let s3 = format!("{}, {}!", s1, s2);

println!("{}", s3); // "Привет, мир!"
println!("{}", s1); // s1 все еще доступна
println!("{}", s2); // s2 все еще доступна
```

Макрос `format!` работает аналогично `println!`, но вместо вывода на экран возвращает отформатированную строку.

### Индексация и срезы строк

В Rust нельзя напрямую индексировать строки с помощью синтаксиса `s[i]`. Это связано с тем, что символы UTF-8 могут занимать разное количество байтов, и простая индексация может привести к неожиданным результатам.

Однако можно создавать срезы строк, если вы уверены, что индексы находятся на границах символов:

```rust
let s = String::from("Привет");

// Создание среза
let slice = &s[0..6]; // "При"

println!("{}", slice);
```

**Предупреждение**: Если индекс не совпадает с границей символа UTF-8, программа вызовет панику:

```rust
let s = String::from("Привет");
let slice = &s[0..1]; // Ошибка: байтовый индекс 1 не является границей символа
```

### Итерация по строкам

Для безопасной работы с символами в строках Rust предоставляет несколько методов итерации:

#### 1. Итерация по байтам

```rust
let s = String::from("Привет");

// Итерация по байтам
for b in s.bytes() {
    println!("{}", b);
}
```

#### 2. Итерация по символам (скалярным значениям Unicode)

```rust
let s = String::from("Привет");

// Итерация по символам
for c in s.chars() {
    println!("{}", c);
}
```

#### 3. Итерация по графемам (видимым символам)

Для работы с графемами (комбинациями символов, которые воспринимаются как один видимый символ) можно использовать крейт `unicode-segmentation`:

```rust
use unicode_segmentation::UnicodeSegmentation;

fn main() {
    let s = String::from("café");
    
    // Итерация по графемам
    for g in s.graphemes(true) {
        println!("{}", g);
    }
}
```

## Сравнение String и &str

| Характеристика | String | &str |
|----------------|--------|------|
| Владение данными | Владеет данными | Не владеет данными (ссылка) |
| Изменяемость | Может быть изменяемой | Всегда неизменяемая |
| Хранение | В куче | Может указывать на данные в куче или в бинарном файле программы |
| Время жизни | Не требует аннотаций времени жизни | Требует аннотации времени жизни (кроме `'static`) |
| Использование | Когда нужно владеть и/или изменять строку | Когда нужна только ссылка на строку |

## Преобразование между String и &str

### Из &str в String

```rust
// Метод to_string()
let s = "привет".to_string();

// Метод String::from()
let s = String::from("привет");
```

### Из String в &str

```rust
let s = String::from("привет");

// Неявное преобразование при передаче ссылки
let slice: &str = &s;

// Явное преобразование
let slice = s.as_str();
```

## Практические примеры работы со строками

### Пример 1: Подсчет слов в тексте

```rust
fn count_words(text: &str) -> usize {
    text.split_whitespace().count()
}

fn main() {
    let text = "Rust - это системный язык программирования, \
                который очень быстрый и предотвращает почти все ошибки сегментации.";
    
    let word_count = count_words(text);
    println!("Количество слов: {}", word_count);
}
```

### Пример 2: Проверка палиндрома

```rust
fn is_palindrome(text: &str) -> bool {
    // Приводим к нижнему регистру и удаляем не буквенно-цифровые символы
    let cleaned: String = text
        .to_lowercase()
        .chars()
        .filter(|c| c.is_alphanumeric())
        .collect();
    
    // Сравниваем с перевернутой версией
    let reversed: String = cleaned.chars().rev().collect();
    
    cleaned == reversed
}

fn main() {
    let examples = [
        "А роза упала на лапу Азора",
        "Rust is fun",
        "Madam, I'm Adam",
    ];
    
    for &example in &examples {
        if is_palindrome(example) {
            println!("\"{}\" - палиндром", example);
        } else {
            println!("\"{}\" - не палиндром", example);
        }
    }
}
```

### Пример 3: Обработка строк с использованием регулярных выражений

```rust
use regex::Regex;

fn extract_emails(text: &str) -> Vec<String> {
    let re = Regex::new(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b").unwrap();
    
    re.find_iter(text)
        .map(|mat| mat.as_str().to_string())
        .collect()
}

fn main() {
    let text = "Свяжитесь с нами по адресам: support@example.com или 
                sales@example.com. Наш технический специалист (tech@example.org) 
                также готов помочь.";
    
    let emails = extract_emails(text);
    
    println!("Найденные email-адреса:");
    for email in emails {
        println!("- {}", email);
    }
}
```

### Пример 4: Форматирование строк

```rust
fn main() {
    let name = "Анна";
    let age = 30;
    let city = "Москва";
    
    // Простое форматирование
    let info = format!("Меня зовут {}, мне {} лет, я из города {}.", name, age, city);
    println!("{}", info);
    
    // Именованные аргументы
    let info = format!(
        "Имя: {name}, Возраст: {age}, Город: {city}",
        name = name,
        age = age,
        city = city
    );
    println!("{}", info);
    
    // Позиционные аргументы
    let info = format!("{0} живет в городе {2} и {0} {1} лет.", name, age, city);
    println!("{}", info);
    
    // Форматирование чисел
    println!("Десятичное: {}", 42);
    println!("Двоичное: {:b}", 42);
    println!("Шестнадцатеричное: {:x}", 42);
    println!("С ведущими нулями: {:08}", 42); // 00000042
    
    // Форматирование чисел с плавающей точкой
    println!("С двумя знаками после запятой: {:.2}", 1.234567);
    
    // Выравнивание
    println!("Выравнивание по правому краю: {:>10}", "текст");
    println!("Выравнивание по левому краю: {:<10}", "текст");
    println!("По центру: {:^10}", "текст");
    println!("С заполнителем: {:*^10}", "текст");
}
```

## Эффективная работа со строками в Rust

### 1. Выбор правильного типа

- Используйте `&str` для параметров функций, когда не нужно владеть строкой или изменять ее
- Используйте `String`, когда нужно владеть строкой или изменять ее
- Возвращайте `String` из функций, когда создаете новую строку

```rust
// Хорошо: принимает &str (можно передать и &str, и String)
fn process_text(text: &str) -> String {
    format!("Обработано: {}", text)
}

// Менее гибко: принимает только String
fn process_text_limited(text: String) -> String {
    format!("Обработано: {}", text)
}
```

### 2. Избегайте ненужных преобразований

```rust
// Неэффективно: лишнее преобразование
fn count_words_inefficient(text: &str) -> usize {
    let owned_string = text.to_string(); // Ненужное преобразование
    owned_string.split_whitespace().count()
}

// Эффективно: работаем напрямую с &str
fn count_words_efficient(text: &str) -> usize {
    text.split_whitespace().count()
}
```

### 3. Используйте методы строк вместо ручной обработки

```rust
// Менее идиоматично
fn trim_manually(s: &str) -> String {
    let mut result = String::new();
    let mut chars = s.chars();
    
    // Пропускаем начальные пробелы
    while let Some(c) = chars.next() {
        if !c.is_whitespace() {
            result.push(c);
            break;
        }
    }
    
    // Добавляем остальные символы
    for c in chars {
        result.push(c);
    }
    
    // Удаляем конечные пробелы
    while let Some(c) = result.chars().last() {
        if c.is_whitespace() {
            result.pop();
        } else {
            break;
        }
    }
    
    result
}

// Идиоматично и эффективно
fn trim_properly(s: &str) -> &str {
    s.trim()
}
```

### 4. Используйте `String::with_capacity` для оптимизации производительности

```rust
fn build_greeting(name: &str) -> String {
    // Неоптимально: будет несколько перераспределений памяти
    let mut greeting = String::new();
    greeting.push_str("Привет, ");
    greeting.push_str(name);
    greeting.push_str("! Добро пожаловать.");
    
    greeting
}

fn build_greeting_optimized(name: &str) -> String {
    // Оптимально: выделяем память сразу с запасом
    let capacity = 9 + name.len() + 18; // "Привет, " + name + "! Добро пожаловать."
    let mut greeting = String::with_capacity(capacity);
    greeting.push_str("Привет, ");
    greeting.push_str(name);
    greeting.push_str("! Добро пожаловать.");
    
    greeting
}
```

### 5. Используйте макрос `format!` для сложного форматирования

```rust
// Менее читаемо
fn create_message(name: &str, count: usize) -> String {
    let mut message = String::from("Уважаемый ");
    message.push_str(name);
    message.push_str(", у вас ");
    message.push_str(&count.to_string());
    message.push_str(" непрочитанных сообщений.");
    message
}

// Более читаемо и поддерживаемо
fn create_message_formatted(name: &str, count: usize) -> String {
    format!("Уважаемый {}, у вас {} непрочитанных сообщений.", name, count)
}
```

## Работа с Unicode в строках

Rust полностью поддерживает Unicode, что позволяет корректно работать с текстом на разных языках. Однако это также создает определенные сложности при работе со строками.

### Длина строки и количество символов

Метод `len()` возвращает количество байтов в строке, а не количество символов:

```rust
let english = "hello";
let russian = "привет";

println!("Длина 'hello' в байтах: {}", english.len()); // 5
println!("Длина 'привет' в байтах: {}", russian.len()); // 12

println!("Количество символов в 'hello': {}", english.chars().count()); // 5
println!("Количество символов в 'привет': {}", russian.chars().count()); // 6
```

### Работа с символами разной длины

```rust
fn main() {
    let text = "Привет, 世界!"; // Смесь кириллицы, латиницы и китайских иероглифов
    
    println!("Текст: {}", text);
    println!("Длина в байтах: {}", text.len());
    println!("Количество символов: {}", text.chars().count());
    
    println!("\nСимволы и их размеры:");
    for (i, c) in text.chars().enumerate() {
        let char_size = c.len_utf8();
        println!("Символ {}: '{}' (размер: {} байт)", i, c, char_size);
    }
}
```

## Заключение

Строки в Rust имеют некоторые особенности по сравнению с другими языками программирования, что обусловлено фокусом языка на безопасности памяти и корректной работе с Unicode. Понимание различий между типами `String` и `&str`, а также знание методов эффективной работы со строками, позволит вам писать более надежный и производительный код.

Ключевые моменты для запоминания:
1. `&str` - это неизменяемый строковый срез, который не владеет данными
2. `String` - это изменяемая строка, которая владеет своими данными и хранится в куче
3. Строки в Rust всегда являются валидными последовательностями UTF-8
4. Нельзя напрямую индексировать строки из-за переменной длины символов UTF-8
5. Для работы с отдельными символами используйте методы `.chars()` или `.bytes()`
6. Для параметров функций предпочтительнее использовать `&str`, чтобы обеспечить большую гибкость

Эффективная работа со строками - важный навык при программировании на Rust, который поможет вам создавать надежные и производительные приложения.