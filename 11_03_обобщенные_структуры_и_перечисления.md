# Обобщенные структуры и перечисления в Rust

Обобщенные типы данных (generic types) - это один из ключевых механизмов Rust, позволяющий создавать гибкие и повторно используемые структуры данных. В этом разделе мы рассмотрим, как создавать и использовать обобщенные структуры и перечисления.

## Обобщенные структуры

Обобщенная структура объявляется с использованием параметров типа в угловых скобках `<>` после имени структуры:

```rust
struct Point<T> {
    x: T,
    y: T,
}
```

В этом примере `T` - это параметр типа, который может быть заменен любым конкретным типом при создании экземпляра структуры.

### Создание экземпляров обобщенных структур

Чтобы создать экземпляр обобщенной структуры, мы указываем конкретный тип в угловых скобках:

```rust
fn main() {
    let integer_point = Point::<i32> { x: 5, y: 10 };
    let float_point = Point::<f64> { x: 1.0, y: 4.0 };
}
```

Однако в большинстве случаев Rust может вывести тип из контекста, поэтому мы можем опустить явное указание типа:

```rust
fn main() {
    let integer_point = Point { x: 5, y: 10 };     // Point<i32>
    let float_point = Point { x: 1.0, y: 4.0 };    // Point<f64>
}
```

### Структуры с несколькими параметрами типа

Структура может иметь несколько параметров типа:

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let mixed_point = Point { x: 5, y: 4.0 };  // Point<i32, f64>
}
```

В этом примере `x` и `y` могут иметь разные типы.

### Реализация методов для обобщенных структур

Чтобы реализовать методы для обобщенной структуры, мы используем блок `impl` с параметрами типа:

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
    
    fn y(&self) -> &T {
        &self.y
    }
}
```

Обратите внимание на синтаксис `impl<T> Point<T>`. Здесь мы сначала объявляем параметр типа `T`, а затем указываем, что реализуем методы для типа `Point<T>`.

### Методы с ограничениями типов

Мы можем добавить ограничения типов для методов обобщенных структур:

```rust
impl<T: std::fmt::Display> Point<T> {
    fn print(&self) {
        println!("Point coordinates: ({}, {})", self.x, self.y);
    }
}
```

В этом примере метод `print` будет доступен только для тех `Point<T>`, где `T` реализует трейт `Display`.

### Методы для конкретных типов

Мы также можем реализовать методы только для конкретных типов:

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

Этот метод будет доступен только для `Point<f32>`, но не для других типов, таких как `Point<i32>` или `Point<String>`.

### Методы с собственными параметрами типа

Методы могут иметь свои собственные параметры типа, которые отличаются от параметров типа структуры:

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}
```

В этом примере метод `mixup` имеет свои собственные параметры типа `V` и `W`, которые отличаются от параметров типа `T` и `U` структуры `Point`.

## Обобщенные перечисления

Перечисления (enums) в Rust также могут быть обобщенными:

```rust
enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Это два примера из стандартной библиотеки Rust. `Option<T>` представляет значение, которое может отсутствовать, а `Result<T, E>` представляет результат операции, которая может завершиться ошибкой.

### Создание экземпляров обобщенных перечислений

Создание экземпляров обобщенных перечислений аналогично созданию экземпляров обобщенных структур:

```rust
fn main() {
    let some_integer = Some(5);          // Option<i32>
    let some_float = Some(5.0);          // Option<f64>
    let absent_number: Option<i32> = None; // Нужно указать тип, так как Rust не может его вывести
    
    let ok_result: Result<i32, String> = Ok(42);
    let err_result: Result<i32, String> = Err(String::from("Something went wrong"));
}
```

### Реализация методов для обобщенных перечислений

Методы для обобщенных перечислений реализуются так же, как и для обобщенных структур:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

impl<T, E> Result<T, E> {
    fn is_ok(&self) -> bool {
        match self {
            Result::Ok(_) => true,
            Result::Err(_) => false,
        }
    }
    
    fn is_err(&self) -> bool {
        !self.is_ok()
    }
}
```

## Обобщенные типы в стандартной библиотеке

Стандартная библиотека Rust широко использует обобщенные типы. Вот несколько примеров:

### Vec<T>

`Vec<T>` - это динамический массив, который может хранить элементы любого типа:

```rust
fn main() {
    let v1: Vec<i32> = Vec::new();
    let v2 = vec![1, 2, 3];  // vec! - это макрос для создания Vec<T>
    
    let v3: Vec<String> = Vec::new();
    let v4 = vec![String::from("hello"), String::from("world")];
}
```

### HashMap<K, V>

`HashMap<K, V>` - это хеш-таблица, которая отображает ключи типа `K` на значения типа `V`:

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
}
```

### Box<T>

`Box<T>` - это умный указатель, который хранит данные в куче:

```rust
fn main() {
    let b = Box::new(5);  // Box<i32>
}
```

## Производительность обобщенных типов

Как и в случае с обобщенными функциями, использование обобщенных типов в Rust не приводит к снижению производительности во время выполнения благодаря процессу мономорфизации.

Во время компиляции Rust генерирует отдельные версии обобщенных типов для каждого конкретного типа, с которым они используются. Таким образом, использование обобщенного типа с конкретным типом так же эффективно, как если бы тип был написан специально для этого конкретного типа.

## Заключение

Обобщенные структуры и перечисления - это мощные инструменты в Rust, которые позволяют создавать гибкие, повторно используемые типы данных без потери производительности. Они являются основой для многих стандартных типов данных в Rust, таких как `Vec<T>`, `Option<T>`, `Result<T, E>` и многих других.

В следующем разделе мы рассмотрим, как использовать ограничения типов для обеспечения определенного поведения обобщенных типов и функций.