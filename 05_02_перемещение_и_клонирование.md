# Перемещение (move) и клонирование (clone) в Rust

В предыдущей теме мы рассмотрели основные принципы системы владения в Rust. Теперь углубимся в два важных механизма, которые используются при передаче данных: перемещение (move) и клонирование (clone).

## Перемещение (move)

Перемещение - это механизм, при котором владение значением передается от одной переменной к другой. После перемещения исходная переменная становится недействительной, и компилятор не позволит использовать ее.

### Как работает перемещение

Рассмотрим пример со строкой:

```rust
let s1 = String::from("привет");
let s2 = s1;

// println!("{}", s1); // Ошибка компиляции: значение перемещено
println!("{}", s2);    // Работает
```

Когда мы присваиваем `s1` переменной `s2`, происходит следующее:

1. Переменная `s2` получает владение данными, на которые указывала `s1`.
2. Переменная `s1` становится недействительной.
3. Компилятор гарантирует, что `s1` больше не будет использоваться.

Это предотвращает проблему "двойного освобождения" памяти, когда две переменные пытаются освободить одну и ту же область памяти.

### Внутреннее представление строк

Чтобы лучше понять, почему происходит перемещение, рассмотрим внутреннее представление типа `String`:

```
┌─────────────┐
│ String      │
├─────────────┤
│ ptr         │──────► ┌──────────────────┐
│ len         │        │ привет           │
│ capacity    │        └──────────────────┘
└─────────────┘
```

Тип `String` состоит из трех частей:
- `ptr` - указатель на память, где хранятся данные строки
- `len` - длина строки в байтах
- `capacity` - общий объем памяти, выделенный для строки

Когда мы присваиваем `s1` переменной `s2`, копируются только эти три значения (указатель, длина и емкость), но не сами данные строки:

```
s1:
┌─────────────┐
│ String      │
├─────────────┤
│ ptr         │──┐
│ len         │  │    ┌──────────────────┐
│ capacity    │  └───►│ привет           │
└─────────────┘       └──────────────────┘
                      ▲
s2:                   │
┌─────────────┐       │
│ String      │       │
├─────────────┤       │
│ ptr         │───────┘
│ len         │
│ capacity    │
└─────────────┘
```

Если бы обе переменные `s1` и `s2` были действительны и обе пытались бы освободить одну и ту же память при выходе из области видимости, это привело бы к ошибке "двойного освобождения". Rust предотвращает эту проблему, делая `s1` недействительной после перемещения.

### Перемещение в функциях

Перемещение также происходит при передаче значений в функции:

```rust
fn main() {
    let s = String::from("привет");
    
    takes_ownership(s);
    
    // println!("{}", s); // Ошибка: значение перемещено
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // some_string выходит из области видимости и память освобождается
```

Здесь владение строкой `s` передается функции `takes_ownership`. После вызова функции переменная `s` становится недействительной.

## Клонирование (clone)

Если мы хотим создать полную копию данных, а не просто переместить владение, мы можем использовать метод `clone()`:

```rust
let s1 = String::from("привет");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2); // Обе переменные действительны
```

При вызове `clone()` создается полная копия данных в куче:

```
s1:
┌─────────────┐
│ String      │
├─────────────┤
│ ptr         │──────► ┌──────────────────┐
│ len         │        │ привет           │
│ capacity    │        └──────────────────┘
└─────────────┘

s2:
┌─────────────┐
│ String      │
├─────────────┤
│ ptr         │──────► ┌──────────────────┐
│ len         │        │ привет           │
│ capacity    │        └──────────────────┘
└─────────────┘
```

Теперь у нас есть две независимые строки, и каждая из них будет освобождена отдельно при выходе из области видимости.

### Производительность клонирования

Клонирование может быть дорогостоящей операцией, особенно для больших структур данных, поскольку оно создает полную копию всех данных. Поэтому в Rust клонирование всегда явное - вы должны вызвать метод `clone()`, чтобы создать копию.

```rust
// Создание большого вектора
let large_vec = vec![1; 1_000_000]; // Вектор из 1 миллиона единиц

// Клонирование большого вектора (может быть медленным)
let large_vec_clone = large_vec.clone();
```

## Трейт Copy

Некоторые типы в Rust реализуют трейт `Copy`. Для таких типов вместо перемещения происходит копирование значения при присваивании:

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y); // Обе переменные действительны
```

Здесь `x` и `y` - это два независимых значения `5`, хранящихся в стеке. После присваивания `y = x` обе переменные можно использовать.

### Типы, реализующие Copy

Следующие типы реализуют трейт `Copy`:

- Все целочисленные типы (`i32`, `u64` и т.д.)
- Булевы типы (`bool`)
- Типы с плавающей точкой (`f32`, `f64`)
- Символьный тип (`char`)
- Кортежи, если все их элементы реализуют `Copy` (например, `(i32, i32)`)
- Массивы фиксированного размера, если их элементы реализуют `Copy`

### Реализация трейта Copy для пользовательских типов

Мы можем реализовать трейт `Copy` для наших собственных типов, если все их поля также реализуют `Copy`:

```rust
#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = p1; // Копирование, а не перемещение
    
    println!("p1: ({}, {}), p2: ({}, {})", p1.x, p1.y, p2.x, p2.y);
}
```

Обратите внимание, что мы должны также реализовать трейт `Clone`, поскольку `Copy` является подтрейтом `Clone`.

### Когда нельзя реализовать Copy

Тип не может реализовать `Copy`, если:

1. Он содержит поля, которые не реализуют `Copy` (например, `String`, `Vec`)
2. Он реализует трейт `Drop` (имеет деструктор)

```rust
struct HasString {
    s: String, // String не реализует Copy
}

// Нельзя реализовать Copy для HasString
// #[derive(Copy, Clone)] // Ошибка компиляции
```

## Перемещение vs Клонирование vs Copy

Давайте сравним эти три механизма:

### Перемещение (Move)
- Передает владение от одной переменной к другой
- Исходная переменная становится недействительной
- Не копирует данные в куче
- Применяется по умолчанию для типов, не реализующих `Copy`

### Клонирование (Clone)
- Создает полную копию данных, включая данные в куче
- Обе переменные остаются действительными
- Может быть дорогостоящей операцией
- Требует явного вызова метода `clone()`

### Копирование (Copy)
- Создает копию данных на стеке
- Обе переменные остаются действительными
- Быстрая операция (обычно просто копирование нескольких байтов)
- Происходит автоматически при присваивании для типов, реализующих `Copy`

## Практические примеры

### Пример 1: Работа со строками

```rust
fn main() {
    // Перемещение
    let s1 = String::from("привет");
    let s2 = s1;
    // println!("{}", s1); // Ошибка: значение перемещено
    
    // Клонирование
    let s3 = String::from("мир");
    let s4 = s3.clone();
    println!("s3 = {}, s4 = {}", s3, s4); // Обе действительны
}
```

### Пример 2: Функции и возврат владения

```rust
fn main() {
    let s1 = String::from("привет");
    
    let s2 = takes_and_gives_back(s1);
    // println!("{}", s1); // Ошибка: значение перемещено
    println!("{}", s2); // Работает
    
    let x = 5;
    makes_copy(x);
    println!("{}", x); // Работает, потому что i32 реализует Copy
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string // возвращаем владение вызывающей стороне
}

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
}
```

### Пример 3: Клонирование сложных структур

```rust
fn main() {
    let v1 = vec![String::from("привет"), String::from("мир")];
    
    // Клонирование вектора и всех его элементов
    let v2 = v1.clone();
    
    println!("v1[0] = {}, v2[0] = {}", v1[0], v2[0]);
}
```

## Заключение

Перемещение и клонирование - это два фундаментальных механизма в системе владения Rust:

- **Перемещение** обеспечивает безопасность памяти, предотвращая двойное освобождение и другие ошибки.
- **Клонирование** предоставляет гибкость, позволяя создавать полные копии данных, когда это необходимо.
- **Трейт Copy** упрощает работу с простыми типами, автоматически копируя их при присваивании.

Понимание этих механизмов критически важно для эффективного программирования на Rust. Они позволяют Rust обеспечивать безопасность памяти без сборщика мусора, сохраняя при этом высокую производительность.

В следующей теме мы рассмотрим стек и кучу - две области памяти, которые играют важную роль в системе владения Rust.