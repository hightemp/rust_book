# Векторы в Rust

Вектор (`Vec<T>`) - это одна из наиболее часто используемых коллекций в Rust. Он представляет собой динамический массив, который может изменять свой размер во время выполнения программы. Векторы хранят элементы одного типа и размещаются в куче, что делает их более гибкими по сравнению с обычными массивами.

## Создание векторов

Существует несколько способов создания векторов в Rust:

### Использование макроса `vec!`

Самый простой способ создать вектор с начальными значениями - использовать макрос `vec!`:

```rust
// Создание вектора с элементами
let numbers = vec![1, 2, 3, 4, 5];

// Создание вектора с повторяющимся значением
let zeros = vec![0; 10]; // Вектор из 10 нулей
```

### Использование метода `Vec::new()`

Для создания пустого вектора можно использовать метод `Vec::new()`:

```rust
// Создание пустого вектора
let mut empty_vec: Vec<i32> = Vec::new();

// Тип можно опустить, если компилятор может его вывести
let mut names = Vec::new();
names.push("Alice"); // Теперь компилятор знает, что это Vec<&str>
```

### Использование метода `Vec::with_capacity()`

Если вы заранее знаете примерное количество элементов, которые будут добавлены в вектор, можно использовать `Vec::with_capacity()` для оптимизации производительности:

```rust
// Создание вектора с предварительно выделенной памятью для 10 элементов
let mut with_capacity = Vec::with_capacity(10);

println!("Длина: {}, Емкость: {}", with_capacity.len(), with_capacity.capacity());
// Выведет: "Длина: 0, Емкость: 10"
```

## Добавление элементов в вектор

Для добавления элементов в вектор используется метод `push()`:

```rust
let mut numbers = Vec::new();

// Добавление элементов
numbers.push(1);
numbers.push(2);
numbers.push(3);

println!("Вектор: {:?}", numbers); // Выведет: "Вектор: [1, 2, 3]"
```

Также можно добавить несколько элементов сразу с помощью метода `extend()`:

```rust
let mut v1 = vec![1, 2, 3];
let v2 = vec![4, 5, 6];

// Добавление всех элементов из v2 в v1
v1.extend(v2);

println!("Расширенный вектор: {:?}", v1); // Выведет: "Расширенный вектор: [1, 2, 3, 4, 5, 6]"
```

## Доступ к элементам вектора

Существует два основных способа доступа к элементам вектора:

### 1. Индексация

Можно получить доступ к элементам вектора с помощью индексации, как и в случае с массивами:

```rust
let v = vec![10, 20, 30, 40, 50];

// Доступ по индексу
let third = v[2]; // 30

println!("Третий элемент: {}", third);
```

Однако, если вы попытаетесь обратиться к несуществующему индексу, программа вызовет панику:

```rust
let v = vec![1, 2, 3];
let value = v[10]; // Ошибка времени выполнения: индекс выходит за границы
```

### 2. Метод `get()`

Более безопасный способ доступа к элементам - использование метода `get()`, который возвращает `Option<&T>`:

```rust
let v = vec![10, 20, 30, 40, 50];

// Безопасный доступ с использованием get()
match v.get(2) {
    Some(value) => println!("Третий элемент: {}", value),
    None => println!("Третий элемент не существует"),
}

// Проверка несуществующего индекса
match v.get(100) {
    Some(value) => println!("Элемент с индексом 100: {}", value),
    None => println!("Элемент с индексом 100 не существует"),
}
```

## Изменение элементов вектора

Если вектор объявлен как изменяемый (`mut`), его элементы можно изменять:

```rust
let mut v = vec![10, 20, 30];

// Изменение элемента
v[1] = 25;

println!("Измененный вектор: {:?}", v); // Выведет: "Измененный вектор: [10, 25, 30]"
```

## Удаление элементов из вектора

Для удаления элементов из вектора можно использовать различные методы:

### Метод `pop()`

Удаляет и возвращает последний элемент вектора:

```rust
let mut v = vec![1, 2, 3, 4];

let last = v.pop(); // Удаляет и возвращает 4

println!("Удаленный элемент: {:?}", last); // Выведет: "Удаленный элемент: Some(4)"
println!("Вектор после удаления: {:?}", v); // Выведет: "Вектор после удаления: [1, 2, 3]"
```

### Метод `remove()`

Удаляет элемент по указанному индексу и сдвигает все последующие элементы:

```rust
let mut v = vec![10, 20, 30, 40, 50];

let removed = v.remove(2); // Удаляет элемент с индексом 2 (значение 30)

println!("Удаленный элемент: {}", removed); // Выведет: "Удаленный элемент: 30"
println!("Вектор после удаления: {:?}", v); // Выведет: "Вектор после удаления: [10, 20, 40, 50]"
```

### Метод `clear()`

Удаляет все элементы из вектора:

```rust
let mut v = vec![1, 2, 3, 4, 5];

v.clear(); // Удаляет все элементы

println!("Длина после очистки: {}", v.len()); // Выведет: "Длина после очистки: 0"
```

## Итерация по вектору

Существует несколько способов перебора элементов вектора:

### Простая итерация

```rust
let v = vec![10, 20, 30, 40, 50];

// Перебор элементов
for element in &v {
    println!("Элемент: {}", element);
}
```

### Итерация с изменением элементов

```rust
let mut v = vec![10, 20, 30, 40, 50];

// Перебор с изменением элементов
for element in &mut v {
    *element += 5; // Увеличиваем каждый элемент на 5
}

println!("Измененный вектор: {:?}", v); // Выведет: "Измененный вектор: [15, 25, 35, 45, 55]"
```

### Итерация с индексами

```rust
let v = vec![10, 20, 30, 40, 50];

// Перебор с индексами
for (index, value) in v.iter().enumerate() {
    println!("v[{}] = {}", index, value);
}
```

## Сортировка и поиск в векторах

### Сортировка вектора

```rust
let mut numbers = vec![5, 2, 8, 1, 9, 3];

// Сортировка по возрастанию
numbers.sort();
println!("Отсортированный вектор: {:?}", numbers); // [1, 2, 3, 5, 8, 9]

// Сортировка по убыванию
numbers.sort_by(|a, b| b.cmp(a));
println!("Отсортированный по убыванию: {:?}", numbers); // [9, 8, 5, 3, 2, 1]

// Сортировка с пользовательской функцией сравнения
let mut pairs = vec![(1, 5), (2, 3), (5, 2)];
pairs.sort_by_key(|&(_, b)| b);
println!("Отсортированный по второму элементу: {:?}", pairs); // [(5, 2), (2, 3), (1, 5)]
```

### Поиск в векторе

```rust
let numbers = vec![10, 20, 30, 40, 50];

// Поиск элемента
let position = numbers.iter().position(|&x| x == 30);
println!("Позиция элемента 30: {:?}", position); // Some(2)

// Поиск несуществующего элемента
let position = numbers.iter().position(|&x| x == 35);
println!("Позиция элемента 35: {:?}", position); // None

// Проверка наличия элемента
let contains = numbers.contains(&40);
println!("Содержит 40: {}", contains); // true
```

## Векторы и владение

Как и другие типы данных в Rust, векторы подчиняются правилам владения. Когда вектор выходит из области видимости, он и все его элементы освобождаются:

```rust
{
    let v = vec![String::from("hello"), String::from("world")];
    // v владеет всеми строками
} // Здесь v выходит из области видимости и освобождается вместе со всеми строками
```

При работе с ссылками на элементы вектора необходимо учитывать правила заимствования:

```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0]; // Неизменяемое заимствование

// v.push(6); // Ошибка: нельзя одновременно иметь неизменяемую и изменяемую ссылки

println!("Первый элемент: {}", first); // Используем неизменяемую ссылку

// Теперь можно изменять вектор
v.push(6);
println!("Вектор после добавления: {:?}", v);
```

## Векторы разных типов с использованием перечислений

Векторы могут содержать только элементы одного типа. Однако с помощью перечислений (enums) можно создать вектор, который будет хранить значения разных типов:

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(42),
    SpreadsheetCell::Float(3.14),
    SpreadsheetCell::Text(String::from("hello")),
];

// Обработка элементов разных типов
for cell in &row {
    match cell {
        SpreadsheetCell::Int(i) => println!("Целое число: {}", i),
        SpreadsheetCell::Float(f) => println!("Число с плавающей точкой: {}", f),
        SpreadsheetCell::Text(s) => println!("Текст: {}", s),
    }
}
```

## Производительность и оптимизация векторов

### Предварительное выделение памяти

Если вы знаете примерное количество элементов, которые будут добавлены в вектор, используйте `Vec::with_capacity()` для оптимизации производительности:

```rust
// Неоптимально: будет несколько перераспределений памяти
let mut v1 = Vec::new();
for i in 0..10000 {
    v1.push(i);
}

// Оптимально: память выделяется сразу
let mut v2 = Vec::with_capacity(10000);
for i in 0..10000 {
    v2.push(i);
}
```

### Уменьшение размера вектора

Если вектор содержит гораздо меньше элементов, чем его емкость, можно использовать метод `shrink_to_fit()` для освобождения неиспользуемой памяти:

```rust
let mut v = Vec::with_capacity(10000);
v.push(1);
v.push(2);
v.push(3);

println!("Длина: {}, Емкость: {}", v.len(), v.capacity()); // Длина: 3, Емкость: 10000

// Уменьшаем емкость до фактического размера
v.shrink_to_fit();

println!("После shrink_to_fit - Длина: {}, Емкость: {}", v.len(), v.capacity());
// Емкость будет близка к 3
```

### Резервирование дополнительной памяти

Если вы планируете добавить больше элементов в вектор, можно использовать методы `reserve()` или `reserve_exact()`:

```rust
let mut v = vec![1, 2, 3];

// Резервирование памяти для дополнительных элементов
v.reserve(10); // Гарантирует, что емкость будет не менее len() + 10

println!("После reserve - Длина: {}, Емкость: {}", v.len(), v.capacity());
```

## Практические примеры использования векторов

### Пример 1: Фильтрация и преобразование данных

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    // Фильтрация четных чисел и их удвоение
    let even_doubled: Vec<i32> = numbers
        .iter()
        .filter(|&&n| n % 2 == 0)
        .map(|&n| n * 2)
        .collect();
    
    println!("Четные числа, умноженные на 2: {:?}", even_doubled);
    // Выведет: "Четные числа, умноженные на 2: [4, 8, 12, 16, 20]"
}
```

### Пример 2: Группировка данных

```rust
use std::collections::HashMap;

fn main() {
    let names = vec!["Alice", "Bob", "Charlie", "Anna", "Bob", "David", "Alice"];
    
    // Группировка имен по первой букве
    let mut grouped: HashMap<char, Vec<&str>> = HashMap::new();
    
    for &name in &names {
        let first_char = name.chars().next().unwrap();
        grouped.entry(first_char).or_insert_with(Vec::new).push(name);
    }
    
    // Вывод сгруппированных имен
    for (letter, names) in &grouped {
        println!("{}: {:?}", letter, names);
    }
}
```

### Пример 3: Реализация стека и очереди с использованием вектора

```rust
// Реализация стека
struct Stack<T> {
    elements: Vec<T>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Stack {
            elements: Vec::new(),
        }
    }
    
    fn push(&mut self, element: T) {
        self.elements.push(element);
    }
    
    fn pop(&mut self) -> Option<T> {
        self.elements.pop()
    }
    
    fn peek(&self) -> Option<&T> {
        self.elements.last()
    }
    
    fn is_empty(&self) -> bool {
        self.elements.is_empty()
    }
    
    fn size(&self) -> usize {
        self.elements.len()
    }
}

// Реализация очереди
struct Queue<T> {
    elements: Vec<T>,
}

impl<T> Queue<T> {
    fn new() -> Self {
        Queue {
            elements: Vec::new(),
        }
    }
    
    fn enqueue(&mut self, element: T) {
        self.elements.push(element);
    }
    
    fn dequeue(&mut self) -> Option<T> {
        if self.elements.is_empty() {
            None
        } else {
            Some(self.elements.remove(0))
        }
    }
    
    fn peek(&self) -> Option<&T> {
        self.elements.first()
    }
    
    fn is_empty(&self) -> bool {
        self.elements.is_empty()
    }
    
    fn size(&self) -> usize {
        self.elements.len()
    }
}

fn main() {
    // Использование стека
    let mut stack = Stack::new();
    stack.push(1);
    stack.push(2);
    stack.push(3);
    
    println!("Верхний элемент стека: {:?}", stack.peek());
    println!("Извлечение из стека: {:?}", stack.pop());
    println!("Размер стека после извлечения: {}", stack.size());
    
    // Использование очереди
    let mut queue = Queue::new();
    queue.enqueue("first");
    queue.enqueue("second");
    queue.enqueue("third");
    
    println!("Первый элемент очереди: {:?}", queue.peek());
    println!("Извлечение из очереди: {:?}", queue.dequeue());
    println!("Размер очереди после извлечения: {}", queue.size());
}
```

### Пример 4: Обработка матрицы с использованием вектора векторов

```rust
fn main() {
    // Создание матрицы 3x3
    let matrix = vec![
        vec![1, 2, 3],
        vec![4, 5, 6],
        vec![7, 8, 9]
    ];
    
    // Вывод матрицы
    println!("Исходная матрица:");
    print_matrix(&matrix);
    
    // Вычисление суммы элементов матрицы
    let sum: i32 = matrix.iter()
        .flat_map(|row| row.iter())
        .sum();
    
    println!("Сумма всех элементов: {}", sum);
    
    // Транспонирование матрицы
    let transposed = transpose(&matrix);
    
    println!("Транспонированная матрица:");
    print_matrix(&transposed);
}

// Функция для вывода матрицы
fn print_matrix(matrix: &Vec<Vec<i32>>) {
    for row in matrix {
        for &element in row {
            print!("{:4}", element);
        }
        println!();
    }
}

// Функция для транспонирования матрицы
fn transpose(matrix: &Vec<Vec<i32>>) -> Vec<Vec<i32>> {
    let rows = matrix.len();
    let cols = matrix[0].len();
    
    let mut result = vec![vec![0; rows]; cols];
    
    for i in 0..rows {
        for j in 0..cols {
            result[j][i] = matrix[i][j];
        }
    }
    
    result
}
```

## Лучшие практики использования векторов

1. **Используйте `Vec::with_capacity()`**, когда заранее известно примерное количество элементов, чтобы избежать лишних перераспределений памяти.

2. **Предпочитайте методы итераторов** для обработки векторов вместо индексации, так как они более выразительны и безопасны:
   ```rust
   // Предпочтительно
   let sum: i32 = numbers.iter().sum();
   
   // Менее идиоматично
   let mut sum = 0;
   for i in 0..numbers.len() {
       sum += numbers[i];
   }
   ```

3. **Используйте метод `get()`** вместо индексации `[]`, если есть вероятность выхода за границы вектора:
   ```rust
   // Безопасно
   if let Some(value) = numbers.get(index) {
       println!("Значение: {}", value);
   }
   
   // Может вызвать панику
   let value = numbers[index];
   ```

4. **Избегайте частых операций `remove()` в середине вектора**, так как это требует сдвига всех последующих элементов. Если вам нужно часто удалять элементы из середины коллекции, рассмотрите использование `LinkedList` или другой структуры данных.

5. **Используйте `drain()` для эффективного удаления диапазона элементов**:
   ```rust
   let mut v = vec![1, 2, 3, 4, 5];
   let drained: Vec<_> = v.drain(1..4).collect();
   // v теперь [1, 5], drained содержит [2, 3, 4]
   ```

6. **Используйте `retain()` для фильтрации элементов на месте**:
   ```rust
   let mut numbers = vec![1, 2, 3, 4, 5, 6];
   numbers.retain(|&x| x % 2 == 0); // Оставляем только четные числа
   // numbers теперь [2, 4, 6]
   ```

7. **Используйте `dedup()` для удаления последовательных дубликатов**:
   ```rust
   let mut v = vec![1, 2, 2, 3, 3, 3, 4, 5, 5];
   v.dedup();
   // v теперь [1, 2, 3, 4, 5]
   ```

## Заключение

Векторы (`Vec<T>`) - это мощный и гибкий тип коллекции в Rust, который позволяет хранить последовательности элементов одного типа с динамическим размером. Они являются основой для многих алгоритмов и структур данных и широко используются в программах на Rust.

Ключевые особенности векторов:
- Динамический размер, который может изменяться во время выполнения программы
- Хранение элементов одного типа
- Эффективный доступ к элементам по индексу (O(1))
- Автоматическое управление памятью
- Богатый набор методов для работы с данными

Понимание векторов и умение эффективно их использовать - важный навык для программирования на Rust, который поможет вам создавать более гибкие и производительные приложения.