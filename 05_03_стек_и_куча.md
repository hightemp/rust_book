# Стек и куча в Rust

Понимание того, как Rust использует стек и кучу, является важной частью понимания системы владения. В этой теме мы рассмотрим, что такое стек и куча, как они работают, и как Rust использует их для управления памятью.

## Что такое стек и куча?

Стек и куча - это две области памяти, которые программа может использовать во время выполнения:

### Стек (Stack)

Стек - это область памяти, которая работает по принципу "последним пришел - первым ушел" (LIFO, Last In, First Out). Представьте стопку тарелок: вы можете добавить тарелку сверху или снять верхнюю тарелку, но не можете вытащить тарелку из середины стопки.

Основные характеристики стека:
- Очень быстрый доступ к данным
- Данные должны иметь известный, фиксированный размер
- Данные выделяются и освобождаются автоматически при входе и выходе из области видимости
- Ограниченный размер (обычно несколько МБ)

### Куча (Heap)

Куча - это область памяти, которая не имеет таких строгих ограничений на организацию данных. Вы можете запросить блок памяти определенного размера, и операционная система найдет свободное место в куче и вернет указатель на него.

Основные характеристики кучи:
- Более медленный доступ к данным по сравнению со стеком
- Данные могут иметь динамический размер
- Данные должны явно выделяться и освобождаться
- Практически неограниченный размер (ограничен только доступной памятью)

## Как Rust использует стек и кучу

### Данные на стеке

Следующие типы данных обычно хранятся на стеке:
- Целые числа (`i32`, `u64` и т.д.)
- Числа с плавающей точкой (`f32`, `f64`)
- Булевы значения (`bool`)
- Символы (`char`)
- Кортежи, содержащие только типы, которые также хранятся на стеке
- Массивы фиксированного размера
- Ссылки (указатели)

Пример данных на стеке:

```rust
fn main() {
    let x = 42; // целое число на стеке
    let y = true; // булево значение на стеке
    let z = 'Z'; // символ на стеке
    let coords = (10, 20); // кортеж на стеке
    let array = [1, 2, 3, 4, 5]; // массив фиксированного размера на стеке
}
```

### Данные в куче

Следующие типы данных обычно хранятся в куче:
- Строки (`String`)
- Векторы (`Vec<T>`)
- Хеш-карты (`HashMap<K, V>`)
- Другие коллекции
- Объекты типа `Box<T>`
- Другие типы с динамическим размером

Пример данных в куче:

```rust
fn main() {
    let s = String::from("привет"); // строка в куче
    let v = vec![1, 2, 3]; // вектор в куче
    let b = Box::new(42); // целое число в куче (обернуто в Box)
}
```

## Как работает стек

Рассмотрим, как работает стек на примере вызова функций:

```rust
fn main() {
    let a = 10;
    let result = square(a);
    println!("Квадрат {} равен {}", a, result);
}

fn square(x: i32) -> i32 {
    let result = x * x;
    result
}
```

Вот что происходит в памяти:

1. Программа начинает выполнение функции `main`.
2. На стеке выделяется место для переменной `a` и ей присваивается значение `10`.
3. Вызывается функция `square`. Текущее состояние функции `main` сохраняется на стеке.
4. На стеке выделяется место для параметра `x` функции `square` и ему присваивается значение `10`.
5. На стеке выделяется место для переменной `result` функции `square` и ей присваивается значение `100`.
6. Функция `square` возвращает значение `result` и завершается. Память, выделенная для `x` и `result` в функции `square`, освобождается.
7. Выполнение функции `main` продолжается. Возвращенное значение `100` присваивается переменной `result` в `main`.
8. Выполняется `println!`.
9. Функция `main` завершается, и память, выделенная для `a` и `result`, освобождается.

Этот процесс очень эффективен, потому что:
- Выделение и освобождение памяти на стеке - это просто увеличение или уменьшение указателя стека.
- Все размеры известны во время компиляции, поэтому компилятор может оптимизировать доступ к данным.
- Данные расположены близко друг к другу в памяти, что улучшает локальность кэша.

## Как работает куча

Рассмотрим, как работает куча на примере создания строки:

```rust
fn main() {
    let s = String::from("привет");
    // использование s
}
```

Вот что происходит в памяти:

1. Программа запрашивает у операционной системы память для хранения строки "привет".
2. Операционная система находит достаточно большой блок свободной памяти в куче и помечает его как используемый.
3. Операционная система возвращает указатель на эту память.
4. В Rust этот указатель хранится в переменной `s`, которая находится на стеке.
5. Когда `s` выходит из области видимости, Rust автоматически вызывает функцию `drop`, которая освобождает память в куче.

Структура `String` на самом деле состоит из трех частей, которые хранятся на стеке:
- Указатель на память в куче, где хранятся данные
- Длина (сколько байт занимает строка)
- Емкость (сколько байт памяти выделено в куче)

```
Стек:
┌─────────────┐
│ String s    │
├─────────────┤
│ ptr         │──────► Куча:
│ len         │        ┌──────────────────┐
│ capacity    │        │ п р и в е т      │
└─────────────┘        └──────────────────┘
```

## Стек vs Куча: производительность

Выделение памяти на стеке обычно быстрее, чем выделение памяти в куче, по нескольким причинам:

1. **Простота выделения**: Для выделения памяти на стеке достаточно просто увеличить указатель стека. Для выделения памяти в куче нужно найти блок подходящего размера, что может потребовать сложных алгоритмов.

2. **Локальность данных**: Данные на стеке расположены последовательно в памяти, что улучшает локальность кэша и ускоряет доступ к данным.

3. **Отсутствие фрагментации**: Стек не подвержен фрагментации, в отличие от кучи, где многократное выделение и освобождение памяти может привести к фрагментации.

Однако куча предоставляет большую гибкость, позволяя выделять память динамически и хранить данные, размер которых неизвестен во время компиляции или может изменяться.

## Влияние на систему владения

Система владения в Rust тесно связана с тем, как данные хранятся в памяти:

1. **Данные на стеке** обычно реализуют трейт `Copy`, потому что их копирование быстрое и дешевое. Когда вы присваиваете переменную с данными на стеке другой переменной, создается копия данных.

2. **Данные в куче** обычно не реализуют трейт `Copy`, потому что их копирование может быть дорогим. Когда вы присваиваете переменную с данными в куче другой переменной, происходит перемещение владения, а не копирование данных.

Это различие является ключевым для понимания того, почему некоторые типы в Rust перемещаются, а некоторые копируются при присваивании.

## Примеры использования стека и кучи

### Пример 1: Рекурсивная функция и переполнение стека

```rust
fn recursive_function(n: u32) -> u32 {
    if n == 0 {
        return 1;
    }
    recursive_function(n - 1) + 1
}

fn main() {
    // Это может вызвать переполнение стека при больших значениях n
    let result = recursive_function(100000);
    println!("Результат: {}", result);
}
```

При вызове рекурсивной функции каждый новый вызов добавляет новый кадр на стек. Если рекурсия слишком глубокая, стек может переполниться, что приведет к ошибке "stack overflow".

### Пример 2: Хранение больших данных в куче

```rust
fn main() {
    // Создание большого массива в куче
    let large_data = vec![0; 1_000_000]; // Вектор из 1 миллиона нулей
    
    // Обработка данных
    let sum: u32 = large_data.iter().sum();
    println!("Сумма: {}", sum);
}
```

Здесь мы создаем большой вектор, который хранится в куче. Это позволяет нам работать с большими объемами данных, которые не поместились бы на стеке.

### Пример 3: Возврат данных из функции

```rust
fn create_string() -> String {
    let s = String::from("привет, мир");
    s // возвращаем владение строкой вызывающей стороне
}

fn main() {
    let s = create_string();
    println!("{}", s);
}
```

Здесь функция `create_string` создает строку в куче и возвращает владение этой строкой вызывающей функции. Строка не копируется, а перемещается, что делает этот код эффективным.

## Оптимизации компилятора

Компилятор Rust может выполнять различные оптимизации, связанные с использованием стека и кучи:

1. **Встраивание функций (inlining)**: Компилятор может встроить тело небольшой функции в место ее вызова, что уменьшает накладные расходы на вызов функции и использование стека.

2. **Оптимизация хвостовой рекурсии**: В некоторых случаях компилятор может преобразовать рекурсивную функцию в итеративную, что предотвращает переполнение стека.

3. **Элизия копирования (copy elision)**: Компилятор может устранить ненужные копирования и перемещения, что улучшает производительность.

4. **Размещение в регистрах**: Компилятор может хранить часто используемые переменные в регистрах процессора вместо стека, что ускоряет доступ к ним.

## Заключение

Понимание того, как Rust использует стек и кучу, является важным для эффективного программирования:

- **Стек** используется для данных с известным, фиксированным размером. Доступ к данным на стеке быстрый, но размер стека ограничен.
- **Куча** используется для данных с динамическим размером. Доступ к данным в куче медленнее, но размер кучи практически неограничен.

Система владения в Rust тесно связана с этими концепциями:
- Данные на стеке часто реализуют трейт `Copy` и копируются при присваивании.
- Данные в куче обычно перемещаются при присваивании, чтобы избежать дорогостоящего копирования и проблем с освобождением памяти.

В следующей теме мы рассмотрим время жизни переменных и как оно связано с системой владения в Rust.