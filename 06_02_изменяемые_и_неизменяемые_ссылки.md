# Изменяемые и неизменяемые ссылки

В предыдущем разделе мы познакомились с концепцией заимствования в Rust, которая позволяет получить доступ к данным без передачи права владения. Теперь рассмотрим два типа ссылок: изменяемые и неизменяемые, и как они влияют на работу с данными.

## Неизменяемые ссылки

По умолчанию, ссылки в Rust являются неизменяемыми (immutable). Это означает, что через такую ссылку нельзя изменить значение, на которое она указывает:

```rust
fn main() {
    let s = String::from("привет");
    
    // Создаем неизменяемую ссылку
    let r = &s;
    
    println!("Значение по ссылке: {}", r);
    
    // Следующий код вызовет ошибку компиляции:
    // r.push_str(", мир"); // ❌ нельзя изменить значение через неизменяемую ссылку
}
```

Неизменяемые ссылки гарантируют, что значение, на которое они указывают, не будет изменено через эту ссылку. Это важная гарантия для безопасности и предсказуемости кода.

## Изменяемые ссылки

Если нам нужно изменить значение через ссылку, мы должны использовать изменяемую (mutable) ссылку. Изменяемые ссылки создаются с помощью оператора `&mut`:

```rust
fn main() {
    // Обратите внимание, что исходная переменная должна быть изменяемой
    let mut s = String::from("привет");
    
    // Создаем изменяемую ссылку
    let r = &mut s;
    
    // Теперь мы можем изменить значение через ссылку
    r.push_str(", мир");
    
    println!("Измененное значение: {}", r); // Выведет "привет, мир"
}
```

Важно отметить, что для создания изменяемой ссылки исходная переменная также должна быть объявлена как изменяемая с помощью ключевого слова `mut`.

## Правило: только одна изменяемая ссылка

Rust накладывает важное ограничение: в каждый момент времени может существовать только одна изменяемая ссылка на конкретные данные. Это предотвращает состояние гонки (data race) при одновременном изменении данных:

```rust
fn main() {
    let mut s = String::from("привет");
    
    let r1 = &mut s;
    let r2 = &mut s; // ❌ Ошибка: нельзя иметь две изменяемые ссылки одновременно
    
    println!("{}, {}", r1, r2);
}
```

Этот код не скомпилируется, потому что мы пытаемся создать две изменяемые ссылки на одни и те же данные. Это ограничение помогает предотвратить ошибки, связанные с одновременным изменением данных из разных мест.

## Правило: нельзя совмещать изменяемые и неизменяемые ссылки

Еще одно важное правило: нельзя иметь изменяемую ссылку, если уже существует неизменяемая ссылка на те же данные:

```rust
fn main() {
    let mut s = String::from("привет");
    
    let r1 = &s;     // неизменяемая ссылка
    let r2 = &s;     // еще одна неизменяемая ссылка - это допустимо
    let r3 = &mut s; // ❌ Ошибка: нельзя создать изменяемую ссылку, 
                     // когда существуют неизменяемые
    
    println!("{}, {}, {}", r1, r2, r3);
}
```

Это правило предотвращает ситуацию, когда одна часть кода изменяет данные, в то время как другая часть кода рассчитывает на их неизменность.

## Области действия ссылок

Важно понимать, что область действия ссылки заканчивается после ее последнего использования. Это позволяет более гибко работать с ссылками:

```rust
fn main() {
    let mut s = String::from("привет");
    
    let r1 = &s; // неизменяемая ссылка
    let r2 = &s; // еще одна неизменяемая ссылка
    
    println!("{} и {}", r1, r2);
    // r1 и r2 больше не используются после этой точки
    
    let r3 = &mut s; // ✅ Теперь можно создать изменяемую ссылку
    r3.push_str(", мир");
    
    println!("{}", r3);
}
```

Этот код скомпилируется успешно, потому что неизменяемые ссылки `r1` и `r2` используются в последний раз перед созданием изменяемой ссылки `r3`. Компилятор Rust отслеживает, где ссылки используются в последний раз, и позволяет создавать новые ссылки после этой точки.

## Передача ссылок в функции

Изменяемые и неизменяемые ссылки часто используются при передаче аргументов в функции:

```rust
// Функция, принимающая неизменяемую ссылку
fn calculate_length(s: &String) -> usize {
    s.len()
}

// Функция, принимающая изменяемую ссылку
fn append_world(s: &mut String) {
    s.push_str(", мир");
}

fn main() {
    let mut s = String::from("привет");
    
    // Передаем неизменяемую ссылку
    let len = calculate_length(&s);
    println!("Длина строки: {}", len);
    
    // Передаем изменяемую ссылку
    append_world(&mut s);
    println!("Измененная строка: {}", s);
}
```

Это позволяет функциям работать с данными без передачи владения, при этом четко указывая, будут ли данные изменяться.

## Преимущества системы ссылок в Rust

Система изменяемых и неизменяемых ссылок в Rust предоставляет несколько важных преимуществ:

1. **Безопасность**: Предотвращает состояния гонки (data races) на этапе компиляции.
2. **Ясность намерений**: Тип ссылки явно указывает, будут ли данные изменяться.
3. **Оптимизация**: Компилятор может оптимизировать код, зная, что данные не будут изменяться через неизменяемые ссылки.

## Множественные неизменяемые ссылки

В отличие от изменяемых ссылок, можно иметь любое количество неизменяемых ссылок на одни и те же данные:

```rust
fn main() {
    let s = String::from("привет");
    
    let r1 = &s;
    let r2 = &s;
    let r3 = &s;
    
    println!("{}, {}, {}", r1, r2, r3); // ✅ Это допустимо
}
```

Это безопасно, потому что никто не может изменить данные через эти ссылки, поэтому не возникает конфликтов.

## Практические примеры

### Пример 1: Работа со строками

```rust
fn main() {
    let mut message = String::from("Привет");
    
    // Неизменяемая ссылка для чтения
    let greeting = &message;
    println!("Текущее сообщение: {}", greeting);
    
    // Изменяемая ссылка для модификации
    let mut_ref = &mut message;
    mut_ref.push_str(", программист!");
    
    println!("Обновленное сообщение: {}", mut_ref);
}
```

### Пример 2: Работа с векторами

```rust
fn main() {
    let mut numbers = vec![1, 2, 3, 4, 5];
    
    // Чтение через неизменяемую ссылку
    let first_three = &numbers[0..3];
    println!("Первые три числа: {:?}", first_three);
    
    // Изменение через изменяемую ссылку
    let last = &mut numbers[4];
    *last = 10;
    
    println!("Измененный вектор: {:?}", numbers);
}
```

### Пример 3: Функции с разными типами ссылок

```rust
struct User {
    name: String,
    age: u32,
}

// Функция, принимающая неизменяемую ссылку
fn print_user_info(user: &User) {
    println!("Имя: {}, Возраст: {}", user.name, user.age);
}

// Функция, принимающая изменяемую ссылку
fn have_birthday(user: &mut User) {
    user.age += 1;
    println!("С днем рождения! Теперь вам {} лет.", user.age);
}

fn main() {
    let mut user = User {
        name: String::from("Алексей"),
        age: 30,
    };
    
    print_user_info(&user);
    have_birthday(&mut user);
    print_user_info(&user);
}
```

## Заключение

Изменяемые и неизменяемые ссылки - это мощный инструмент в Rust, который позволяет безопасно работать с данными без передачи владения. Правила, которые Rust накладывает на использование ссылок, могут показаться строгими, но они предотвращают множество распространенных ошибок, связанных с параллельным доступом к данным.

В следующем разделе мы более подробно рассмотрим правила заимствования и как они обеспечивают безопасность памяти в Rust.