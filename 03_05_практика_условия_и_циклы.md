# Практика: Решение задач с использованием условий и циклов

В этой главе мы применим на практике знания об условных выражениях, циклах и выражении `match`, полученные в предыдущих разделах. Мы рассмотрим несколько практических задач различной сложности и реализуем их решения на Rust.

## Задача 1: Вычисление факториала

### Описание задачи

Факториал числа n (обозначается как n!) - это произведение всех положительных целых чисел от 1 до n. Например:
- 5! = 5 × 4 × 3 × 2 × 1 = 120
- 0! = 1 (по определению)

Напишите функцию, которая вычисляет факториал заданного числа.

### Решение с использованием цикла for

```rust
fn factorial_for(n: u64) -> u64 {
    // Базовый случай: 0! = 1
    if n == 0 {
        return 1;
    }
    
    // Инициализируем результат
    let mut result = 1;
    
    // Умножаем результат на каждое число от 1 до n
    for i in 1..=n {
        result *= i;
    }
    
    result
}

fn main() {
    println!("5! = {}", factorial_for(5)); // Выведет: 5! = 120
    println!("10! = {}", factorial_for(10)); // Выведет: 10! = 3628800
}
```

### Решение с использованием цикла while

```rust
fn factorial_while(n: u64) -> u64 {
    // Базовый случай: 0! = 1
    if n == 0 {
        return 1;
    }
    
    // Инициализируем результат и счетчик
    let mut result = 1;
    let mut i = 1;
    
    // Умножаем результат на каждое число от 1 до n
    while i <= n {
        result *= i;
        i += 1;
    }
    
    result
}
```

### Решение с использованием рекурсии

```rust
fn factorial_recursive(n: u64) -> u64 {
    // Базовый случай: 0! = 1
    if n == 0 {
        return 1;
    }
    
    // Рекурсивный случай: n! = n * (n-1)!
    n * factorial_recursive(n - 1)
}
```

### Анализ решений

1. **Решение с циклом for**: Наиболее идиоматичный подход в Rust. Цикл `for` с диапазоном `1..=n` перебирает все числа от 1 до n включительно.

2. **Решение с циклом while**: Менее идиоматично для этой задачи, но демонстрирует использование цикла `while`. Требует явного управления счетчиком.

3. **Рекурсивное решение**: Элегантное, но менее эффективное для больших значений n из-за накладных расходов на вызовы функций и риска переполнения стека.

## Задача 2: Числа Фибоначчи

### Описание задачи

Последовательность Фибоначчи - это ряд чисел, где каждое число является суммой двух предыдущих. Первые два числа в последовательности - 0 и 1. Например:
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

Напишите функцию, которая возвращает n-е число Фибоначчи.

### Решение с использованием цикла for

```rust
fn fibonacci(n: u32) -> u64 {
    // Базовые случаи
    if n == 0 {
        return 0;
    } else if n == 1 {
        return 1;
    }
    
    // Инициализируем первые два числа Фибоначчи
    let mut a = 0;
    let mut b = 1;
    
    // Вычисляем n-е число Фибоначчи
    for _ in 2..=n {
        let temp = a + b;
        a = b;
        b = temp;
    }
    
    b
}

fn main() {
    println!("Fibonacci(10) = {}", fibonacci(10)); // Выведет: Fibonacci(10) = 55
    
    // Выводим первые 15 чисел Фибоначчи
    println!("Первые 15 чисел Фибоначчи:");
    for i in 0..15 {
        print!("{} ", fibonacci(i));
    }
    // Выведет: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
}
```

### Решение с использованием match

```rust
fn fibonacci_match(n: u32) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        n => {
            let mut a = 0;
            let mut b = 1;
            
            for _ in 2..=n {
                let temp = a + b;
                a = b;
                b = temp;
            }
            
            b
        }
    }
}
```

### Анализ решений

1. **Решение с циклом for**: Эффективное итеративное решение, которое использует только две переменные для хранения предыдущих чисел Фибоначчи.

2. **Решение с использованием match**: Демонстрирует, как можно использовать выражение `match` для обработки базовых случаев. Внутри ветки `n` используется тот же алгоритм, что и в первом решении.

## Задача 3: Проверка простых чисел

### Описание задачи

Простое число - это натуральное число больше 1, которое не имеет положительных делителей, кроме 1 и самого себя. Например, 2, 3, 5, 7, 11 - простые числа.

Напишите функцию, которая проверяет, является ли заданное число простым.

### Решение с использованием цикла for и оператора break

```rust
fn is_prime(n: u32) -> bool {
    // Числа меньше 2 не являются простыми
    if n < 2 {
        return false;
    }
    
    // Проверяем делители от 2 до sqrt(n)
    let sqrt_n = (n as f64).sqrt() as u32 + 1;
    
    for i in 2..sqrt_n {
        if n % i == 0 {
            // Найден делитель, число не простое
            return false;
        }
    }
    
    // Делителей не найдено, число простое
    true
}

fn main() {
    // Проверяем несколько чисел
    for n in 1..20 {
        if is_prime(n) {
            println!("{} - простое число", n);
        } else {
            println!("{} - не простое число", n);
        }
    }
}
```

### Решение с использованием цикла while и флага

```rust
fn is_prime_while(n: u32) -> bool {
    // Числа меньше 2 не являются простыми
    if n < 2 {
        return false;
    }
    
    // Проверяем делители от 2 до sqrt(n)
    let sqrt_n = (n as f64).sqrt() as u32 + 1;
    let mut i = 2;
    let mut is_prime = true;
    
    while i < sqrt_n && is_prime {
        if n % i == 0 {
            is_prime = false;
        }
        i += 1;
    }
    
    is_prime
}
```

### Анализ решений

1. **Решение с циклом for и оператором break**: Эффективное решение, которое проверяет делители только до квадратного корня из n. Использует ранний возврат для оптимизации.

2. **Решение с циклом while и флагом**: Альтернативный подход, использующий флаг `is_prime` для отслеживания результата. Цикл `while` продолжается, пока не будет найден делитель или не будут проверены все потенциальные делители.

## Задача 4: Поиск наибольшего общего делителя (НОД)

### Описание задачи

Наибольший общий делитель (НОД) двух или более целых чисел - это наибольшее положительное целое число, которое делит каждое из этих чисел без остатка.

Напишите функцию, которая находит НОД двух чисел, используя алгоритм Евклида.

### Решение с использованием цикла while

```rust
fn gcd(mut a: u32, mut b: u32) -> u32 {
    // Базовый случай: если одно из чисел равно 0, то НОД - это другое число
    if b == 0 {
        return a;
    }
    
    // Алгоритм Евклида
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    
    a
}

fn main() {
    println!("НОД(48, 18) = {}", gcd(48, 18)); // Выведет: НОД(48, 18) = 6
    println!("НОД(17, 5) = {}", gcd(17, 5));   // Выведет: НОД(17, 5) = 1
}
```

### Решение с использованием рекурсии

```rust
fn gcd_recursive(a: u32, b: u32) -> u32 {
    // Базовый случай: если b равно 0, то НОД - это a
    if b == 0 {
        return a;
    }
    
    // Рекурсивный случай: НОД(a, b) = НОД(b, a % b)
    gcd_recursive(b, a % b)
}
```

### Анализ решений

1. **Решение с циклом while**: Итеративная реализация алгоритма Евклида. Эффективна и не имеет риска переполнения стека для больших чисел.

2. **Рекурсивное решение**: Элегантная реализация, которая напрямую отражает математическое определение алгоритма Евклида. Однако для очень больших чисел может вызвать переполнение стека.

## Задача 5: Генерация треугольника Паскаля

### Описание задачи

Треугольник Паскаля - это бесконечная треугольная числовая таблица, в которой числа по краям равны 1, а каждое число внутри равно сумме двух чисел над ним.

Напишите функцию, которая генерирует n строк треугольника Паскаля.

### Решение с использованием вложенных циклов

```rust
fn generate_pascal_triangle(n: usize) -> Vec<Vec<u32>> {
    let mut triangle = Vec::with_capacity(n);
    
    for i in 0..n {
        // Создаем новую строку
        let mut row = Vec::with_capacity(i + 1);
        
        for j in 0..=i {
            if j == 0 || j == i {
                // Крайние элементы всегда равны 1
                row.push(1);
            } else {
                // Внутренние элементы равны сумме двух элементов из предыдущей строки
                let prev_row = &triangle[i - 1];
                let value = prev_row[j - 1] + prev_row[j];
                row.push(value);
            }
        }
        
        triangle.push(row);
    }
    
    triangle
}

fn print_pascal_triangle(triangle: &[Vec<u32>]) {
    for row in triangle {
        // Выравниваем треугольник по центру
        for _ in 0..(triangle.len() - row.len()) {
            print!("  ");
        }
        
        for &value in row {
            print!("{:4}", value);
        }
        println!();
    }
}

fn main() {
    let n = 10;
    let triangle = generate_pascal_triangle(n);
    println!("Треугольник Паскаля ({} строк):", n);
    print_pascal_triangle(&triangle);
}
```

### Анализ решения

Это решение использует вложенные циклы для генерации треугольника Паскаля:

1. Внешний цикл `for i in 0..n` перебирает строки треугольника.
2. Внутренний цикл `for j in 0..=i` перебирает элементы в каждой строке.
3. Для крайних элементов (j = 0 или j = i) значение всегда равно 1.
4. Для внутренних элементов значение вычисляется как сумма двух элементов из предыдущей строки.

Функция `print_pascal_triangle` форматирует и выводит треугольник с выравниванием по центру.

## Задача 6: Сортировка массива

### Описание задачи

Реализуйте алгоритм сортировки пузырьком для массива целых чисел.

### Решение с использованием вложенных циклов и условных выражений

```rust
fn bubble_sort(arr: &mut [i32]) {
    let n = arr.len();
    
    // Внешний цикл: количество проходов
    for i in 0..n {
        // Флаг, указывающий, были ли перестановки в текущем проходе
        let mut swapped = false;
        
        // Внутренний цикл: сравнение соседних элементов
        for j in 0..(n - i - 1) {
            if arr[j] > arr[j + 1] {
                // Меняем элементы местами
                arr.swap(j, j + 1);
                swapped = true;
            }
        }
        
        // Если в текущем проходе не было перестановок, массив уже отсортирован
        if !swapped {
            break;
        }
    }
}

fn main() {
    let mut numbers = [64, 34, 25, 12, 22, 11, 90];
    
    println!("Исходный массив: {:?}", numbers);
    
    bubble_sort(&mut numbers);
    
    println!("Отсортированный массив: {:?}", numbers);
}
```

### Анализ решения

Это реализация алгоритма сортировки пузырьком:

1. Внешний цикл `for i in 0..n` определяет количество проходов по массиву.
2. Внутренний цикл `for j in 0..(n - i - 1)` сравнивает соседние элементы и меняет их местами, если они расположены в неправильном порядке.
3. Флаг `swapped` отслеживает, были ли перестановки в текущем проходе. Если перестановок не было, массив уже отсортирован, и мы можем досрочно завершить алгоритм с помощью `break`.
4. Метод `arr.swap(j, j + 1)` используется для обмена элементов массива.

## Задача 7: Поиск наиболее часто встречающегося элемента

### Описание задачи

Напишите функцию, которая находит наиболее часто встречающийся элемент в массиве.

### Решение с использованием HashMap и условных выражений

```rust
use std::collections::HashMap;

fn most_frequent(arr: &[i32]) -> Option<i32> {
    if arr.is_empty() {
        return None;
    }
    
    // Создаем HashMap для подсчета частоты элементов
    let mut frequency = HashMap::new();
    
    // Подсчитываем частоту каждого элемента
    for &num in arr {
        let count = frequency.entry(num).or_insert(0);
        *count += 1;
    }
    
    // Находим элемент с наибольшей частотой
    let mut max_element = arr[0];
    let mut max_count = 0;
    
    for (&element, &count) in &frequency {
        if count > max_count {
            max_element = element;
            max_count = count;
        }
    }
    
    Some(max_element)
}

fn main() {
    let numbers = [1, 2, 3, 2, 2, 4, 5, 2, 6, 7, 7, 7, 7, 7];
    
    match most_frequent(&numbers) {
        Some(element) => println!("Наиболее часто встречающийся элемент: {}", element),
        None => println!("Массив пуст"),
    }
}
```

### Анализ решения

Это решение использует `HashMap` для подсчета частоты элементов:

1. Проверяем, не пуст ли массив. Если пуст, возвращаем `None`.
2. Создаем `HashMap`, где ключ - элемент массива, а значение - количество его вхождений.
3. Проходим по массиву и увеличиваем счетчик для каждого элемента.
4. Находим элемент с наибольшей частотой, проходя по всем записям в `HashMap`.
5. Возвращаем найденный элемент, обернутый в `Some`.

Использование `match` в функции `main` демонстрирует обработку возвращаемого значения типа `Option<i32>`.

## Задача 8: Проверка палиндрома

### Описание задачи

Палиндром - это слово, фраза, число или другая последовательность символов, которая читается одинаково в обоих направлениях (игнорируя пробелы, знаки препинания и регистр).

Напишите функцию, которая проверяет, является ли строка палиндромом.

### Решение с использованием итераторов и условных выражений

```rust
fn is_palindrome(s: &str) -> bool {
    // Преобразуем строку в нижний регистр и удаляем не буквенно-цифровые символы
    let chars: Vec<char> = s
        .to_lowercase()
        .chars()
        .filter(|c| c.is_alphanumeric())
        .collect();
    
    // Пустая строка или строка из одного символа - палиндром
    if chars.len() <= 1 {
        return true;
    }
    
    // Сравниваем символы с начала и с конца
    let mut i = 0;
    let mut j = chars.len() - 1;
    
    while i < j {
        if chars[i] != chars[j] {
            return false;
        }
        i += 1;
        j -= 1;
    }
    
    true
}

fn main() {
    let test_strings = [
        "A man, a plan, a canal: Panama",
        "race a car",
        "Was it a car or a cat I saw?",
        "No 'x' in Nixon",
        "Привет",
    ];
    
    for &s in &test_strings {
        if is_palindrome(s) {
            println!("\"{}\" - палиндром", s);
        } else {
            println!("\"{}\" - не палиндром", s);
        }
    }
}
```

### Альтернативное решение с использованием итераторов

```rust
fn is_palindrome_iter(s: &str) -> bool {
    // Преобразуем строку в нижний регистр и удаляем не буквенно-цифровые символы
    let chars: Vec<char> = s
        .to_lowercase()
        .chars()
        .filter(|c| c.is_alphanumeric())
        .collect();
    
    // Сравниваем символы с начала и с конца с помощью итераторов
    chars.iter().eq(chars.iter().rev())
}
```

### Анализ решений

1. **Решение с циклом while**: Классический подход с двумя указателями, которые двигаются навстречу друг другу. Мы предварительно обрабатываем строку, преобразуя ее в нижний регистр и удаляя все символы, кроме букв и цифр.

2. **Решение с итераторами**: Более идиоматичный подход в Rust. Мы используем метод `eq` для сравнения двух итераторов: прямого и обратного. Это решение более компактное и выразительное.

## Заключение

В этой главе мы рассмотрели различные практические задачи, которые демонстрируют использование условных выражений, циклов и выражения `match` в Rust. Мы увидели, как эти конструкции могут быть применены для решения реальных задач программирования.

Ключевые моменты, которые стоит запомнить:

1. **Условные выражения** (`if`/`else`) полезны для принятия решений на основе условий.
2. **Циклы** (`for`, `while`, `loop`) позволяют многократно выполнять блок кода.
3. **Выражение `match`** предоставляет мощный механизм сопоставления с образцом для обработки различных вариантов данных.
4. **Операторы `break` и `continue`** дают дополнительный контроль над выполнением циклов.
5. **Итераторы** в Rust предоставляют элегантный и эффективный способ работы с последовательностями данных.

Практика - ключ к освоению этих концепций. Попробуйте модифицировать представленные решения или создать свои собственные, чтобы лучше понять, как работают условия и циклы в Rust.